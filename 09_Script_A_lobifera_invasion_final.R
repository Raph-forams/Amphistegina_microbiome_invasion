################################################################################
################################################################################
##                                                                            ##
##                    MICROBIOME ANALYSIS WORKFLOW                            ##
##                 Amphistegina lobifera Invasion Study                      ##
##                                                                            ##
################################################################################
################################################################################

# Author: Raphaël Morard, Christiane Hassenrück & Débora Raposo
# Contact: rmorard@marum.de
# Date: 11.12.2025
# Description: Complete analysis workflow for microbiome characterization of
#              Amphistegina lobifera across invasion gradient (Red Sea to 
#              Mediterranean). Includes data filtering, quality control, 
#              community composition analyses, and functional profiling.
#              
#              Input: Supplementary Material Files S1-S8
#              Output: Figures 2-5, Supplementary Figures S1-S7, Tables S1-S13

################################################################################
##                      WORKING DIRECTORY SETUP                               ##
################################################################################

# Set working directory
# NOTE: Adjust this path to match your local system
# setwd("/path/to/your/analysis/directory")

# Verify working directory
cat("Working directory:", getwd(), "\n")

################################################################################
##                      FOLDER ARCHITECTURE                                   ##
################################################################################

# Expected folder structure:
#
# project_root/
# ├── code/                          # Analysis scripts (this file)
# ├── data/                          # Input data files
# │   ├── Supplementary_Material_S1.tsv
# │   ├── Supplementary_Material_S2.tsv
# │   ├── Supplementary_Material_S3.tsv
# │   ├── Supplementary_Material_S4.tsv
# │   ├── Supplementary_Material_S5.tsv
# │   ├── Supplementary_Material_S6.tsv
# │   ├── Supplementary_Material_S7.txt      # FAPROTAX output
# │   └── Supplementary_Material_S8.txt      # FAPROTAX report
# ├── output/                        # All outputs generated by analysis
# │   ├── Figure_2/                  # Main figure 2 panels
# │   ├── Figure_3/                  # Main figure 3 panels
# │   ├── Figure_4/                  # Main figure 4 panels
# │   ├── Figure_5/                  # Main figure 5 panels
# │   ├── Figure_S1/                 # Supplementary figure S1
# │   ├── Figure_S2/                 # Supplementary figure S2
# │   ├── Figure_S3/                 # Supplementary figure S3
# │   ├── Figure_S4/                 # Supplementary figure S4
# │   ├── Figure_S5/                 # Supplementary figure S5
# │   ├── Figure_S6/                 # Supplementary figure S6
# │   ├── Figure_S7/                 # Supplementary figure S7
# │   └── Supplementary_Tables/      # Statistical results tables
# └── README.md                      # Project documentation

################################################################################
##                    CREATE OUTPUT DIRECTORIES                               ##
################################################################################

cat("\n=== Creating output directory structure ===\n")

# Create all required output directories
output_dirs <- c(
  "../output",
  "../output/Figure_2",
  "../output/Figure_3",
  "../output/Figure_4",
  "../output/Figure_5",
  "../output/Figure_S1",
  "../output/Figure_S2",
  "../output/Figure_S3",
  "../output/Figure_S4",
  "../output/Figure_S5",
  "../output/Figure_S6",
  "../output/Figure_S7",
  "../output/Supplementary_Tables"
)

# Create directories (suppress warnings if they already exist)
for (dir in output_dirs) {
  dir.create(dir, showWarnings = FALSE, recursive = TRUE)
  if (dir.exists(dir)) {
    cat("✓", dir, "\n")
  } else {
    cat("✗ Failed to create:", dir, "\n")
  }
}

cat("\n=== Output directory structure created ===\n\n")

################################################################################
##                       LOAD REQUIRED PACKAGES                               ##
################################################################################

cat("=== Loading required packages ===\n")

# Core packages
library(tidyverse)     # Data manipulation and visualization
library(dplyr)         # Data manipulation
library(tidyr)         # Data tidying
library(ggplot2)       # Plotting

# Analysis packages
library(vegan)         # Community ecology analyses
library(decontam)      # Contaminant identification
library(phyloseq)      # Microbiome data handling
library(car)           # ANOVA assumption testing

# Visualization packages
library(ggrepel)       # Text label positioning
library(viridis)       # Color palettes
library(cowplot)       # Plot arrangements
library(UpSetR)        # UpSet plots
library(scales)        # Scale functions

cat("✓ All packages loaded successfully\n\n")

################################################################################
##                    DATA IMPORT FROM SI FILES                               ##
################################################################################

cat("=== Loading supplementary material files ===\n")

# Sample and PCR metadata
SI_S1 <- read.table("../data/Supplementary_Material_S1.tsv", 
                    header = TRUE, sep = "\t")
cat("✓ S1: Sample collection metadata loaded\n")

SI_S2 <- read.table("../data/Supplementary_Material_S2.tsv", 
                    header = TRUE, sep = "\t")
cat("✓ S2: PCR product and library details loaded\n")

# Eukaryote data
SI_S3 <- read.table("../data/Supplementary_Material_S3.tsv", 
                    header = TRUE, sep = "\t", 
                    row.names = 1, check.names = FALSE)
cat("✓ S3: Eukaryote ASV occurrence table loaded\n")

SI_S4 <- read.table("../data/Supplementary_Material_S4.tsv", 
                    header = TRUE, sep = "\t")
cat("✓ S4: Eukaryote taxonomy and bootstrap values loaded\n")

# Prokaryote data
SI_S5 <- read.table("../data/Supplementary_Material_S5.tsv", 
                    header = TRUE, sep = "\t", 
                    row.names = 1, check.names = FALSE)
cat("✓ S5: Prokaryote ASV occurrence table loaded\n")

SI_S6 <- read.table("../data/Supplementary_Material_S6.tsv", 
                    header = TRUE, sep = "\t")
cat("✓ S6: Prokaryote taxonomy and bootstrap values loaded\n")

cat("\n=== All supplementary material files loaded successfully ===\n\n")

################################################################################
##                   PREPARE METADATA FOR ANALYSIS                            ##
################################################################################

# Merge S1 (sample metadata) and S2 (PCR metadata) for complete metadata
METADATA <- SI_S1 %>%
  dplyr::left_join(SI_S2, by = "Extraction_Voucher", relationship = "many-to-many") %>%
  dplyr::rename(
    DNA_Extraction_Voucher = Extraction_Voucher,
    Sample_DNA_Concentration = sample_DNA_concentration,
    PCR_Product_Voucher = PCR_Product,
    Purified_PCR_Product_Voucher = PCR_Product_Voucher,
    Purified_PCR_product_DNA_concentration = Purified_PCR_DNA_Concentration
  )

# Separate by organism for convenience
EUK_METADATA <- METADATA %>% dplyr::filter(Organism == "Eukaryotes")
PRO_METADATA <- METADATA %>% dplyr::filter(Organism == "Prokaryotes")

# Prepare taxonomy tables (separate taxonomy from bootstrap)
EUK_TAXONOMY <- SI_S4 %>%
  dplyr::select(ASV_ID, Kingdom, Supergroup, Division, Class, Order, Family, Genus, Species, seqlen) %>%
  tibble::column_to_rownames("ASV_ID")

EUK_TAXONOMY_BOOT <- SI_S4 %>%
  dplyr::select(ASV_ID, Kingdom_boot, Supergroup_boot, Division_boot, Class_boot, 
                Order_boot, Family_boot, Genus_boot, Species_boot) %>%
  dplyr::rename(Kingdom = Kingdom_boot, Supergroup = Supergroup_boot, 
                Division = Division_boot, Class = Class_boot,
                Order = Order_boot, Family = Family_boot, 
                Genus = Genus_boot, Species = Species_boot) %>%
  tibble::column_to_rownames("ASV_ID")

PRO_TAXONOMY <- SI_S6 %>%
  dplyr::select(ASV_ID, Kingdom, Phylum, Class, Order, Family, Genus, seqlen) %>%
  tibble::column_to_rownames("ASV_ID")

PRO_TAXONOMY_BOOT <- SI_S6 %>%
  dplyr::select(ASV_ID, Kingdom_boot, Phylum_boot, Class_boot, Order_boot, 
                Family_boot, Genus_boot) %>%
  dplyr::rename(Kingdom = Kingdom_boot, Phylum = Phylum_boot, 
                Class = Class_boot, Order = Order_boot,
                Family = Family_boot, Genus = Genus_boot) %>%
  tibble::column_to_rownames("ASV_ID")

# Occurrence tables are already in correct format (ASVs as rows, samples as columns)
EUK_ASV_OCCURENCE <- SI_S3
PRO_ASV_OCCURENCE <- SI_S5

cat("✓ Data loaded successfully\n")
cat("  Eukaryotes:", nrow(EUK_ASV_OCCURENCE), "ASVs across", ncol(EUK_ASV_OCCURENCE), "samples\n")
cat("  Prokaryotes:", nrow(PRO_ASV_OCCURENCE), "ASVs across", ncol(PRO_ASV_OCCURENCE), "samples\n\n")

##############################################
#         DATA CLEANING WITH FLAGGING        #
##############################################

cat("Beginning data quality filtering...\n")
cat("Criteria:\n")
cat("  - RARE: <3 occurrences OR <10 total reads\n")
cat("  - TAXONOMY: Non-target taxa or low bootstrap support (<90)\n")
cat("  - CONTAMINANTS: Detected by decontam package\n\n")

##############################################
# STEP 1: FLAG RARE ASVs
##############################################

cat("Step 1: Flagging rare ASVs...\n")

# Function to calculate ASV statistics
calculate_asv_stats <- function(asv_table, dataset_name) {
  asv_table %>%
    tibble::rownames_to_column("ASV_ID") %>%
    dplyr::rowwise() %>%
    dplyr::mutate(
      n_occurence = sum(dplyr::c_across(-ASV_ID) > 0),
      n_reads = sum(dplyr::c_across(-ASV_ID), na.rm = FALSE)
    ) %>%
    dplyr::ungroup() %>%
    dplyr::select(ASV_ID, n_occurence, n_reads) %>%
    dplyr::mutate(Dataset = dataset_name)
}

euk_asv_stats <- calculate_asv_stats(EUK_ASV_OCCURENCE, "Eukaryotes")
pro_asv_stats <- calculate_asv_stats(PRO_ASV_OCCURENCE, "Prokaryotes")

# FLAG rare ASVs: < 3 occurrences OR < 10 reads
euk_rare_flagged <- euk_asv_stats %>%
  dplyr::filter(n_occurence < 3 | n_reads < 10) %>%
  dplyr::select(ASV_ID) %>%
  dplyr::mutate(Flag_reason = "Rare", Dataset = "Eukaryotes")

pro_rare_flagged <- pro_asv_stats %>%
  dplyr::filter(n_occurence < 3 | n_reads < 10) %>%
  dplyr::select(ASV_ID) %>%
  dplyr::mutate(Flag_reason = "Rare", Dataset = "Prokaryotes")

cat("  Eukaryotes:", nrow(euk_rare_flagged), "rare ASVs flagged\n")
cat("  Prokaryotes:", nrow(pro_rare_flagged), "rare ASVs flagged\n\n")

##############################################
# STEP 2: FLAG TAXONOMIC ISSUES
##############################################

cat("Step 2: Flagging taxonomic issues...\n")

# Eukaryotic taxonomic flagging
euk_taxonomy_flagged <- EUK_TAXONOMY %>%
  tibble::rownames_to_column(var = "ASV_ID") %>%
  dplyr::left_join(EUK_TAXONOMY_BOOT %>%
                     tibble::rownames_to_column(var = "ASV_ID") %>%
                     dplyr::rename("Kingdom_boot" = "Kingdom",
                                   "Supergroup_boot" = "Supergroup",
                                   "Division_boot" = "Division",
                                   "Class_boot" = "Class") %>%
                     dplyr::select(-Order, -Family, -Genus, -Species),
                   by = "ASV_ID") %>%
  dplyr::filter(Kingdom != "Eukaryota" | Kingdom_boot < 90) %>%
  dplyr::select(ASV_ID) %>%
  dplyr::mutate(Flag_reason = "Taxonomy", Dataset = "Eukaryotes")

# Prokaryotic taxonomic flagging
pro_taxonomy_flagged <- PRO_TAXONOMY %>%
  tibble::rownames_to_column(var = "ASV_ID") %>%
  dplyr::left_join(PRO_TAXONOMY_BOOT %>%
                     tibble::rownames_to_column(var = "ASV_ID") %>%
                     dplyr::rename("Kingdom_boot" = "Kingdom",
                                   "Phylum_boot" = "Phylum",
                                   "Class_boot" = "Class") %>%
                     dplyr::select(-Order, -Family, -Genus),
                   by = "ASV_ID") %>%
  dplyr::filter(Kingdom != "Bacteria" | Order == "Chloroplast" | Kingdom_boot < 90) %>%
  dplyr::select(ASV_ID) %>%
  dplyr::mutate(Flag_reason = "Taxonomy", Dataset = "Prokaryotes")

cat("  Eukaryotes:", nrow(euk_taxonomy_flagged), "taxonomic issues flagged\n")
cat("  Prokaryotes:", nrow(pro_taxonomy_flagged), "taxonomic issues flagged\n\n")

##############################################
# STEP 3: FLAG CONTAMINANTS
##############################################

cat("Step 3: Detecting contaminants with decontam package...\n")

# Prepare metadata for decontamination analysis
# Adjust DNA concentrations based on lab procedures:
# - Environmental samples normalized to 2.5 ng/μl  
# - Single-cell extractions diluted 1:10
# - Replace zero values with 0.01 ng/μl (detection limit)

METADATA.decontam <- rbind(
  # Environmental samples (filter and sediment) - standardized concentration
  (METADATA %>% 
     dplyr::filter(Sample_type == "filter" | Sample_type == "sediment") %>% 
     dplyr::mutate(Sample_DNA_Concentration_norm = 2.50)),
  
  # Single-cell samples - account for 1:10 dilution
  (METADATA %>%
     dplyr::filter(Sample_type == "single_cell" | Sample_type == "NC_single_cell") %>% 
     dplyr::mutate(Sample_DNA_Concentration_norm = Sample_DNA_Concentration/10)),
  
  # Environmental negative controls - use original concentration
  (METADATA %>%
     dplyr::filter(Sample_type == "NC_env") %>% 
     dplyr::mutate(Sample_DNA_Concentration_norm = Sample_DNA_Concentration))
) %>% 
  # Simplify negative control categories
  dplyr::mutate(Sample_type = replace(Sample_type, Sample_type == "NC_env", "Negative")) %>% 
  dplyr::mutate(Sample_type = replace(Sample_type, Sample_type == "NC_single_cell", "Negative")) %>%
  # Replace zero concentrations
  dplyr::mutate(Sample_DNA_Concentration_norm = replace(Sample_DNA_Concentration_norm, 
                                                        Sample_DNA_Concentration_norm == 0, 0.01))

# Create dataset-specific metadata
METADATA.decontam.euk <- METADATA.decontam %>% 
  dplyr::filter(Organism == "Eukaryotes") %>%
  dplyr::distinct(Purified_PCR_Product_Voucher, .keep_all = TRUE)

METADATA.decontam.pro <- METADATA.decontam %>% 
  dplyr::filter(Organism == "Prokaryotes") %>%
  dplyr::distinct(Purified_PCR_Product_Voucher, .keep_all = TRUE)

# Create phyloseq objects
ps_euk <- phyloseq(
  otu_table(EUK_ASV_OCCURENCE, taxa_are_rows = TRUE),
  tax_table(as.matrix(EUK_TAXONOMY)),
  sample_data(METADATA.decontam.euk %>% tibble::column_to_rownames("Purified_PCR_Product_Voucher"))
)

ps_pro <- phyloseq(
  otu_table(PRO_ASV_OCCURENCE, taxa_are_rows = TRUE),
  tax_table(as.matrix(PRO_TAXONOMY)),
  sample_data(METADATA.decontam.pro %>% tibble::column_to_rownames("Purified_PCR_Product_Voucher"))
)

# Apply decontam - frequency-based detection
contamdf.freq.euk <- isContaminant(ps_euk, method = "frequency", conc = "Sample_DNA_Concentration_norm")
contamdf.freq.pro <- isContaminant(ps_pro, method = "frequency", conc = "Sample_DNA_Concentration_norm")

# Apply decontam - prevalence-based detection
sample_data(ps_euk)$is.neg <- sample_data(ps_euk)$Sample_type == "Negative"
sample_data(ps_pro)$is.neg <- sample_data(ps_pro)$Sample_type == "Negative"

contamdf.prev.euk <- isContaminant(ps_euk, method = "prevalence", neg = "is.neg")
contamdf.prev.pro <- isContaminant(ps_pro, method = "prevalence", neg = "is.neg")

# Combine results (union approach)
euk.contam.asv <- rbind(
  contamdf.freq.euk %>% dplyr::filter(contaminant == TRUE) %>% tibble::rownames_to_column(var = "ASV_ID") %>% dplyr::select(ASV_ID),
  contamdf.prev.euk %>% dplyr::filter(contaminant == TRUE) %>% tibble::rownames_to_column(var = "ASV_ID") %>% dplyr::select(ASV_ID)
) %>% dplyr::distinct()

pro.contam.asv <- rbind(
  contamdf.freq.pro %>% dplyr::filter(contaminant == TRUE) %>% tibble::rownames_to_column(var = "ASV_ID") %>% dplyr::select(ASV_ID),
  contamdf.prev.pro %>% dplyr::filter(contaminant == TRUE) %>% tibble::rownames_to_column(var = "ASV_ID") %>% dplyr::select(ASV_ID)
) %>% dplyr::distinct()

euk_contam_flagged <- euk.contam.asv %>%
  dplyr::mutate(Flag_reason = "Contaminant", Dataset = "Eukaryotes")

pro_contam_flagged <- pro.contam.asv %>%
  dplyr::mutate(Flag_reason = "Contaminant", Dataset = "Prokaryotes")

cat("  Eukaryotes:", nrow(euk_contam_flagged), "contaminants flagged\n")
cat("  Prokaryotes:", nrow(pro_contam_flagged), "contaminants flagged\n\n")

##############################################
# COMBINE ALL FLAGS
##############################################

# Combine all flagged ASVs
all_flagged <- rbind(
  euk_rare_flagged,
  pro_rare_flagged,
  euk_taxonomy_flagged,
  pro_taxonomy_flagged,
  euk_contam_flagged,
  pro_contam_flagged
)

# Check for ASVs flagged by multiple reasons
flag_summary <- all_flagged %>%
  dplyr::group_by(Dataset, ASV_ID) %>%
  dplyr::summarize(
    n_flags = n(),
    flags = paste(Flag_reason, collapse = ", "),
    .groups = "drop"
  )

multi_flagged <- flag_summary %>% dplyr::filter(n_flags > 1)
cat("ASVs flagged by multiple criteria:", nrow(multi_flagged), "\n\n")

##############################################
# SEQUENTIAL REMOVAL TRACKING
# Order: Rare → Taxonomy → Contaminants
##############################################

cat("Calculating sequential removal effects...\n")

# Function to calculate sequential effects
calculate_sequential_effects <- function(asv_occurrence, rare_flags, tax_flags, contam_flags, 
                                         metadata, dataset_name) {
  
  # Starting point: exclude negative controls
  samples_to_keep <- metadata %>%
    dplyr::filter(Sample_type != "Negative") %>%
    dplyr::pull(Purified_PCR_Product_Voucher)
  
  asv_filtered <- asv_occurrence %>%
    dplyr::select(dplyr::all_of(samples_to_keep))
  
  initial_reads <- sum(asv_filtered)
  initial_asvs <- nrow(asv_filtered)
  
  # Step 1: Remove RARE ASVs
  asvs_after_rare <- setdiff(rownames(asv_filtered), rare_flags$ASV_ID)
  asv_after_rare <- asv_filtered[asvs_after_rare, ]
  
  reads_after_rare <- sum(asv_after_rare)
  asvs_after_rare_n <- nrow(asv_after_rare)
  
  rare_loss_reads <- initial_reads - reads_after_rare
  rare_loss_asvs <- initial_asvs - asvs_after_rare_n
  
  # Step 2: Remove TAXONOMY issues
  asvs_after_taxonomy <- setdiff(rownames(asv_after_rare), tax_flags$ASV_ID)
  asv_after_taxonomy <- asv_after_rare[asvs_after_taxonomy, ]
  
  reads_after_taxonomy <- sum(asv_after_taxonomy)
  asvs_after_taxonomy_n <- nrow(asv_after_taxonomy)
  
  taxonomy_loss_reads <- reads_after_rare - reads_after_taxonomy
  taxonomy_loss_asvs <- asvs_after_rare_n - asvs_after_taxonomy_n
  
  # Step 3: Remove CONTAMINANTS
  asvs_after_contam <- setdiff(rownames(asv_after_taxonomy), contam_flags$ASV_ID)
  asv_final <- asv_after_taxonomy[asvs_after_contam, ]
  
  final_reads <- sum(asv_final)
  final_asvs <- nrow(asv_final)
  
  contam_loss_reads <- reads_after_taxonomy - final_reads
  contam_loss_asvs <- asvs_after_taxonomy_n - final_asvs
  
  list(
    dataset = dataset_name,
    initial_reads = initial_reads,
    initial_asvs = initial_asvs,
    rare_loss_reads = rare_loss_reads,
    rare_loss_asvs = rare_loss_asvs,
    taxonomy_loss_reads = taxonomy_loss_reads,
    taxonomy_loss_asvs = taxonomy_loss_asvs,
    contam_loss_reads = contam_loss_reads,
    contam_loss_asvs = contam_loss_asvs,
    final_reads = final_reads,
    final_asvs = final_asvs
  )
}

# Calculate for both datasets
euk_sequential <- calculate_sequential_effects(
  EUK_ASV_OCCURENCE, euk_rare_flagged, euk_taxonomy_flagged, euk_contam_flagged,
  METADATA.decontam.euk, "Eukaryotes"
)

pro_sequential <- calculate_sequential_effects(
  PRO_ASV_OCCURENCE, pro_rare_flagged, pro_taxonomy_flagged, pro_contam_flagged,
  METADATA.decontam.pro, "Prokaryotes"
)

# Print summary
cat("\n=== SEQUENTIAL REMOVAL SUMMARY ===\n\n")

cat("EUKARYOTES:\n")
cat("  Initial:", format(euk_sequential$initial_reads, big.mark = ","), "reads,", 
    euk_sequential$initial_asvs, "ASVs\n")
cat("  Lost to RARE removal:", format(euk_sequential$rare_loss_reads, big.mark = ","), "reads,", 
    euk_sequential$rare_loss_asvs, "ASVs\n")
cat("  Lost to TAXONOMY removal:", format(euk_sequential$taxonomy_loss_reads, big.mark = ","), "reads,", 
    euk_sequential$taxonomy_loss_asvs, "ASVs\n")
cat("  Lost to CONTAMINANT removal:", format(euk_sequential$contam_loss_reads, big.mark = ","), "reads,", 
    euk_sequential$contam_loss_asvs, "ASVs\n")
cat("  FINAL:", format(euk_sequential$final_reads, big.mark = ","), "reads,", 
    euk_sequential$final_asvs, "ASVs\n\n")

cat("PROKARYOTES:\n")
cat("  Initial:", format(pro_sequential$initial_reads, big.mark = ","), "reads,", 
    pro_sequential$initial_asvs, "ASVs\n")
cat("  Lost to RARE removal:", format(pro_sequential$rare_loss_reads, big.mark = ","), "reads,", 
    pro_sequential$rare_loss_asvs, "ASVs\n")
cat("  Lost to TAXONOMY removal:", format(pro_sequential$taxonomy_loss_reads, big.mark = ","), "reads,", 
    pro_sequential$taxonomy_loss_asvs, "ASVs\n")
cat("  Lost to CONTAMINANT removal:", format(pro_sequential$contam_loss_reads, big.mark = ","), "reads,", 
    pro_sequential$contam_loss_asvs, "ASVs\n")
cat("  FINAL:", format(pro_sequential$final_reads, big.mark = ","), "reads,", 
    pro_sequential$final_asvs, "ASVs\n\n")

##############################################
# PLOT S1: OVERALL SEQUENTIAL LOSS
##############################################

cat("Creating Figure S1: Overall sequential loss plot...\n")

# Prepare data for plotting
sequential_data <- data.frame(
  Dataset = rep(c("Prokaryotes", "Eukaryotes"), each = 4),
  Category = rep(c("Final retained", "Contaminant loss", "Taxonomic loss", "Rare ASV loss"), 2),
  ASVs = c(
    pro_sequential$final_asvs,
    pro_sequential$contam_loss_asvs,
    pro_sequential$taxonomy_loss_asvs,
    pro_sequential$rare_loss_asvs,
    euk_sequential$final_asvs,
    euk_sequential$contam_loss_asvs,
    euk_sequential$taxonomy_loss_asvs,
    euk_sequential$rare_loss_asvs
  ),
  Reads = c(
    pro_sequential$final_reads,
    pro_sequential$contam_loss_reads,
    pro_sequential$taxonomy_loss_reads,
    pro_sequential$rare_loss_reads,
    euk_sequential$final_reads,
    euk_sequential$contam_loss_reads,
    euk_sequential$taxonomy_loss_reads,
    euk_sequential$rare_loss_reads
  )
)

# Set factor levels for stacking order
sequential_data$Category <- factor(sequential_data$Category,
                                   levels = c("Rare ASV loss", "Taxonomic loss", "Contaminant loss", "Final retained"))

# Format for plotting
sequential_data_plot <- sequential_data %>%
  tidyr::gather(Parameter, data, 3:4, factor_key = FALSE)

# Plot
supplementary_figure_1 <- ggplot(sequential_data_plot, aes(x = Dataset, y = data, fill = Category)) +
  geom_col(position = "stack", color = "white", linewidth = 0.3) +
  scale_fill_manual(values = c(
    "Final retained" = "#2E8B57",
    "Contaminant loss" = "#DC143C",
    "Taxonomic loss" = "#CD853F",
    "Rare ASV loss" = "#4682B4"
  )) +
  facet_wrap(Parameter ~ ., scale = "free", ncol = 2) +
  labs(
    title = "Data Filtering",
    y = "Count",
    x = "Dataset"
  ) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.8),
    strip.background = element_rect(fill = "grey90", color = "black"),
    strip.text = element_text(size = 10, face = "bold"),
    legend.position = "bottom",
    legend.title = element_text(size = 11, face = "bold"),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12, face = "bold"),
    plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
    aspect.ratio = 1
  )

# Save figure
ggsave("../output/Figure_S1/Supplementary_Figure_S1.pdf", 
       supplementary_figure_1,
       width = 10, height = 8, dpi = 300)

cat("✓ Figure S1 saved\n\n")

##############################################
# PLOT S2: PER SAMPLE-TYPE EFFECTS (% LOST)
##############################################

cat("Creating Figure S2: Per-sample filtering effects...\n")

# Function to calculate per-sample effects
calculate_per_sample_effects <- function(asv_occurrence, metadata, rare_flags, tax_flags, 
                                         contam_flags, dataset_name) {
  
  # Prepare data: samples as rows, ASVs as columns
  asv_t <- asv_occurrence %>%
    t() %>%
    as.data.frame() %>%
    tibble::rownames_to_column("Purified_PCR_Product_Voucher")
  
  # Join with metadata
  sample_data <- asv_t %>%
    dplyr::inner_join(metadata %>% dplyr::select(Purified_PCR_Product_Voucher, Sample_type, Site, Substrate),
                      by = "Purified_PCR_Product_Voucher") %>%
    dplyr::filter(Sample_type != "Negative")
  
  # Calculate metrics at each stage
  results <- data.frame()
  
  for (i in 1:nrow(sample_data)) {
    sample_id <- sample_data$Purified_PCR_Product_Voucher[i]
    sample_type <- sample_data$Sample_type[i]
    
    # Get ASV counts for this sample
    asv_counts <- sample_data[i, ] %>%
      dplyr::select(-Purified_PCR_Product_Voucher, -Sample_type, -Site, -Substrate) %>%
      unlist()
    
    # Initial state
    initial_reads <- sum(asv_counts)
    initial_asvs <- sum(asv_counts > 0)
    
    # After removing RARE
    asv_names <- names(asv_counts)
    keep_after_rare <- !asv_names %in% rare_flags$ASV_ID
    counts_after_rare <- asv_counts[keep_after_rare]
    reads_after_rare <- sum(counts_after_rare)
    asvs_after_rare <- sum(counts_after_rare > 0)
    
    # After removing TAXONOMY
    keep_after_tax <- !names(counts_after_rare) %in% tax_flags$ASV_ID
    counts_after_tax <- counts_after_rare[keep_after_tax]
    reads_after_tax <- sum(counts_after_tax)
    asvs_after_tax <- sum(counts_after_tax > 0)
    
    # After removing CONTAMINANTS
    keep_after_contam <- !names(counts_after_tax) %in% contam_flags$ASV_ID
    counts_final <- counts_after_tax[keep_after_contam]
    final_reads <- sum(counts_final)
    final_asvs <- sum(counts_final > 0)
    
    # Store results
    results <- rbind(results, data.frame(
      Sample_ID = sample_id,
      Sample_type = sample_type,
      Dataset = dataset_name,
      Initial_reads = initial_reads,
      After_rare_reads = reads_after_rare,
      After_taxonomy_reads = reads_after_tax,
      Final_reads = final_reads,
      Initial_ASVs = initial_asvs,
      After_rare_ASVs = asvs_after_rare,
      After_taxonomy_ASVs = asvs_after_tax,
      Final_ASVs = final_asvs
    ))
  }
  
  return(results)
}

# Calculate per-sample effects
euk_per_sample <- calculate_per_sample_effects(
  EUK_ASV_OCCURENCE, METADATA.decontam.euk, 
  euk_rare_flagged, euk_taxonomy_flagged, euk_contam_flagged,
  "Eukaryotes"
)

pro_per_sample <- calculate_per_sample_effects(
  PRO_ASV_OCCURENCE, METADATA.decontam.pro,
  pro_rare_flagged, pro_taxonomy_flagged, pro_contam_flagged,
  "Prokaryotes"
)

# Combine both datasets
all_per_sample <- rbind(euk_per_sample, pro_per_sample)

# Calculate percentage lost at each stage
all_per_sample_pct <- all_per_sample %>%
  dplyr::mutate(
    # Percentage of READS lost at each stage
    Pct_reads_lost_rare = 100 * (Initial_reads - After_rare_reads) / Initial_reads,
    Pct_reads_lost_taxonomy = 100 * (After_rare_reads - After_taxonomy_reads) / Initial_reads,
    Pct_reads_lost_contaminant = 100 * (After_taxonomy_reads - Final_reads) / Initial_reads,
    Pct_reads_retained = 100 * Final_reads / Initial_reads,
    
    # Percentage of ASVs lost at each stage
    Pct_asvs_lost_rare = 100 * (Initial_ASVs - After_rare_ASVs) / Initial_ASVs,
    Pct_asvs_lost_taxonomy = 100 * (After_rare_ASVs - After_taxonomy_ASVs) / Initial_ASVs,
    Pct_asvs_lost_contaminant = 100 * (After_taxonomy_ASVs - Final_ASVs) / Initial_ASVs,
    Pct_asvs_retained = 100 * Final_ASVs / Initial_ASVs
  )

# Reshape for plotting - READS PERCENTAGE
reads_pct_long <- all_per_sample_pct %>%
  dplyr::select(Sample_ID, Sample_type, Dataset, 
                Pct_reads_lost_rare, Pct_reads_lost_taxonomy, 
                Pct_reads_lost_contaminant, Pct_reads_retained) %>%
  tidyr::gather(Stage, Percentage, Pct_reads_lost_rare:Pct_reads_retained) %>%
  dplyr::mutate(Stage = factor(Stage, 
                               levels = c("Pct_reads_lost_rare", "Pct_reads_lost_taxonomy", 
                                          "Pct_reads_lost_contaminant", "Pct_reads_retained"),
                               labels = c("Rare ASVs\nremoved", "Taxonomy\nremoved", 
                                          "Contaminants\nremoved", "Final\nretained")))

# Reshape for plotting - ASVs PERCENTAGE
asvs_pct_long <- all_per_sample_pct %>%
  dplyr::select(Sample_ID, Sample_type, Dataset, 
                Pct_asvs_lost_rare, Pct_asvs_lost_taxonomy, 
                Pct_asvs_lost_contaminant, Pct_asvs_retained) %>%
  tidyr::gather(Stage, Percentage, Pct_asvs_lost_rare:Pct_asvs_retained) %>%
  dplyr::mutate(Stage = factor(Stage, 
                               levels = c("Pct_asvs_lost_rare", "Pct_asvs_lost_taxonomy", 
                                          "Pct_asvs_lost_contaminant", "Pct_asvs_retained"),
                               labels = c("Rare ASVs\nremoved", "Taxonomy\nremoved", 
                                          "Contaminants\nremoved", "Final\nretained")))

# Define colors for filtering stages
stage_colors <- c(
  "Rare ASVs\nremoved" = "#4682B4",
  "Taxonomy\nremoved" = "#CD853F",
  "Contaminants\nremoved" = "#DC143C",
  "Final\nretained" = "#2E8B57"
)

# Plot 2A: READS PERCENTAGE per sample type
plot_reads_pct_per_type <- ggplot(reads_pct_long, 
                                  aes(x = Sample_type, y = Percentage, fill = Stage)) +
  geom_boxplot(alpha = 0.7, outlier.size = 1, position = position_dodge(width = 0.9)) +
  scale_fill_manual(values = stage_colors, name = "Filtering Stage") +
  scale_x_discrete(labels = c("filter" = "Seawater", 
                              "sediment" = "Sediment", 
                              "single_cell" = "Foraminifera")) +
  facet_wrap(~Dataset, ncol = 1) +
  labs(
    title = "Percentage of Reads Lost/Retained by Filtering Stage",
    x = "Sample Type",
    y = "Percentage of Initial Reads (%)"
  ) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.8),
    panel.grid.major.x = element_blank(),
    strip.background = element_rect(fill = "grey90", color = "black"),
    strip.text = element_text(size = 11, face = "bold"),
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 11),
    axis.text.x = element_text(angle = 0, hjust = 0.5, size = 10),
    axis.text.y = element_text(size = 10),
    axis.title = element_text(size = 12, face = "bold"),
    legend.position = "bottom",
    legend.title = element_text(size = 11, face = "bold")
  )

# Plot 2B: ASVs PERCENTAGE per sample type
plot_asvs_pct_per_type <- ggplot(asvs_pct_long, 
                                 aes(x = Sample_type, y = Percentage, fill = Stage)) +
  geom_boxplot(alpha = 0.7, outlier.size = 1, position = position_dodge(width = 0.9)) +
  scale_fill_manual(values = stage_colors, name = "Filtering Stage") +
  scale_x_discrete(labels = c("filter" = "Seawater", 
                              "sediment" = "Sediment", 
                              "single_cell" = "Foraminifera")) +
  facet_wrap(~Dataset, ncol = 1) +
  labs(
    title = "Percentage of ASVs Lost/Retained by Filtering Stage",
    x = "Sample Type",
    y = "Percentage of Initial ASVs (%)"
  ) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.8),
    panel.grid.major.x = element_blank(),
    strip.background = element_rect(fill = "grey90", color = "black"),
    strip.text = element_text(size = 11, face = "bold"),
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 11),
    axis.text.x = element_text(angle = 0, hjust = 0.5, size = 10),
    axis.text.y = element_text(size = 10),
    axis.title = element_text(size = 12, face = "bold"),
    legend.position = "bottom",
    legend.title = element_text(size = 11, face = "bold")
  )

# Combine both plots
combined_pct_plots <- plot_grid(
  plot_reads_pct_per_type, plot_asvs_pct_per_type,
  ncol = 2,
  labels = c("A", "B"),
  rel_widths = c(1, 1)
)

# Save combined figure
ggsave("../output/Figure_S2/Supplementary_Figure_S2.pdf", 
       combined_pct_plots,
       width = 16, height = 10, dpi = 300)

cat("✓ Figure S2 saved\n\n")

##############################################
#   TECHNICAL REPLICATE SIMILARITY ANALYSIS  #
#   (Bray-Curtis distances)                  #
##############################################

cat("Creating Figure S3: Technical replicate analysis...\n")

##############################################
# PREPARE DATA FOR DISTANCE CALCULATIONS
##############################################

# Function to prepare data for distance analysis
prepare_distance_data <- function(asv_occurrence, asvs_to_remove, metadata, dataset_name) {
  
  # Remove flagged ASVs
  asvs_to_keep <- setdiff(rownames(asv_occurrence), asvs_to_remove)
  
  # Create clean community matrix (samples as rows, ASVs as columns)
  community_matrix <- asv_occurrence[asvs_to_keep, ] %>%
    t() %>%
    as.data.frame() %>%
    tibble::rownames_to_column("Purified_PCR_Product_Voucher") %>%
    # Remove negative controls
    dplyr::anti_join(metadata %>% 
                       dplyr::filter(Sample_type == "Negative") %>%
                       dplyr::select(Purified_PCR_Product_Voucher),
                     by = "Purified_PCR_Product_Voucher")
  
  # Add metadata
  community_with_metadata <- community_matrix %>%
    dplyr::inner_join(METADATA %>% 
                        dplyr::select(Purified_PCR_Product_Voucher, DNA_Extraction_Voucher, 
                                      Sample_type, Site, Substrate),
                      by = "Purified_PCR_Product_Voucher")
  
  return(community_with_metadata)
}

# Prepare data for both datasets
euk_asvs_to_remove <- unique(c(
  euk_rare_flagged$ASV_ID,
  euk_taxonomy_flagged$ASV_ID,
  euk_contam_flagged$ASV_ID
))

pro_asvs_to_remove <- unique(c(
  pro_rare_flagged$ASV_ID,
  pro_taxonomy_flagged$ASV_ID,
  pro_contam_flagged$ASV_ID
))

euk_community <- prepare_distance_data(EUK_ASV_OCCURENCE, euk_asvs_to_remove, 
                                       METADATA.decontam.euk, "Eukaryotes")
pro_community <- prepare_distance_data(PRO_ASV_OCCURENCE, pro_asvs_to_remove, 
                                       METADATA.decontam.pro, "Prokaryotes")

##############################################
# CALCULATE BRAY-CURTIS DISTANCES
##############################################

cat("  Calculating Bray-Curtis distances...\n")

# Function to calculate Bray-Curtis and classify distances
calculate_replicate_distances <- function(community_data, dataset_name) {
  
  # Separate community data from metadata
  metadata_cols <- c("Purified_PCR_Product_Voucher", "DNA_Extraction_Voucher", 
                     "Sample_type", "Site", "Substrate")
  
  community_matrix <- community_data %>%
    dplyr::select(-dplyr::all_of(metadata_cols)) %>%
    as.matrix()
  
  rownames(community_matrix) <- community_data$Purified_PCR_Product_Voucher
  
  # Calculate Bray-Curtis dissimilarity
  bc_dist <- vegdist(community_matrix, method = "bray")
  bc_matrix <- as.matrix(bc_dist)
  
  # Extract metadata
  sample_metadata <- community_data %>%
    dplyr::select(dplyr::all_of(metadata_cols))
  
  # Create pairwise comparison dataframe
  distance_data <- data.frame()
  
  n_samples <- nrow(sample_metadata)
  
  for (i in 1:(n_samples - 1)) {
    for (j in (i + 1):n_samples) {
      
      pcr1 <- sample_metadata$Purified_PCR_Product_Voucher[i]
      pcr2 <- sample_metadata$Purified_PCR_Product_Voucher[j]
      
      extraction1 <- sample_metadata$DNA_Extraction_Voucher[i]
      extraction2 <- sample_metadata$DNA_Extraction_Voucher[j]
      
      type1 <- sample_metadata$Sample_type[i]
      type2 <- sample_metadata$Sample_type[j]
      
      site1 <- sample_metadata$Site[i]
      site2 <- sample_metadata$Site[j]
      
      # Determine comparison type
      if (extraction1 == extraction2) {
        comparison_type <- "Technical replicates"
        sample_type_comparison <- type1  # Same sample type for replicates
      } else if (type1 == type2) {
        comparison_type <- "Between samples (same type)"
        sample_type_comparison <- type1
      } else {
        comparison_type <- "Between samples (different type)"
        sample_type_comparison <- "Mixed"
      }
      
      distance_data <- rbind(distance_data, data.frame(
        PCR1 = pcr1,
        PCR2 = pcr2,
        Extraction1 = extraction1,
        Extraction2 = extraction2,
        Sample_type1 = type1,
        Sample_type2 = type2,
        Sample_type_comparison = sample_type_comparison,
        Site1 = site1,
        Site2 = site2,
        Comparison_type = comparison_type,
        Bray_Curtis_distance = bc_matrix[i, j],
        Dataset = dataset_name
      ))
    }
  }
  
  return(distance_data)
}

# Calculate distances for both datasets
euk_distances <- calculate_replicate_distances(euk_community, "Eukaryotes")
pro_distances <- calculate_replicate_distances(pro_community, "Prokaryotes")

# Combine both datasets
all_distances <- rbind(euk_distances, pro_distances)

##############################################
# SUMMARY STATISTICS
##############################################

cat("  Computing summary statistics...\n")

distance_summary <- all_distances %>%
  dplyr::group_by(Dataset, Comparison_type) %>%
  dplyr::summarize(
    n_comparisons = n(),
    mean_distance = round(mean(Bray_Curtis_distance), 3),
    sd_distance = round(sd(Bray_Curtis_distance), 3),
    median_distance = round(median(Bray_Curtis_distance), 3),
    min_distance = round(min(Bray_Curtis_distance), 3),
    max_distance = round(max(Bray_Curtis_distance), 3),
    .groups = "drop"
  )

# Summary by sample type
distance_summary_by_type <- all_distances %>%
  dplyr::filter(Comparison_type != "Between samples (different type)") %>%
  dplyr::group_by(Dataset, Comparison_type, Sample_type_comparison) %>%
  dplyr::summarize(
    n_comparisons = n(),
    mean_distance = round(mean(Bray_Curtis_distance), 3),
    sd_distance = round(sd(Bray_Curtis_distance), 3),
    median_distance = round(median(Bray_Curtis_distance), 3),
    .groups = "drop"
  )

##############################################
# STATISTICAL TESTS
##############################################

cat("  Running statistical tests...\n")

# Compare technical replicates vs between-sample distances
for (ds in c("Eukaryotes", "Prokaryotes")) {
  
  tech_rep <- all_distances %>%
    dplyr::filter(Dataset == ds, Comparison_type == "Technical replicates") %>%
    dplyr::pull(Bray_Curtis_distance)
  
  between_same <- all_distances %>%
    dplyr::filter(Dataset == ds, Comparison_type == "Between samples (same type)") %>%
    dplyr::pull(Bray_Curtis_distance)
  
  between_diff <- all_distances %>%
    dplyr::filter(Dataset == ds, Comparison_type == "Between samples (different type)") %>%
    dplyr::pull(Bray_Curtis_distance)
  
  # Tech reps vs same type
  test1 <- wilcox.test(tech_rep, between_same)
  
  # Tech reps vs different type
  test2 <- wilcox.test(tech_rep, between_diff)
}

##############################################
# PLOT S3
##############################################

# Define colors
comparison_colors <- c(
  "Technical replicates" = "#2E8B57",
  "Between samples (same type)" = "#FF8C00",
  "Between samples (different type)" = "#DC143C"
)

# Overall comparison boxplot
plot_distnances_replicates <- ggplot(all_distances, 
                                     aes(x = Comparison_type, y = Bray_Curtis_distance, 
                                         fill = Comparison_type)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +  # outlier.shape = NA removes outliers
  geom_jitter(width = 0.2, alpha = 0.2, size = 0.5) +
  scale_fill_manual(values = comparison_colors) +
  facet_wrap(~Dataset, ncol = 2) +
  labs(
    title = "Bray-Curtis Distances: Technical Replicates vs Between-Sample Comparisons",
    x = "Comparison Type",
    y = "Bray-Curtis Distance"
  ) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.8),
    strip.background = element_rect(fill = "grey90", color = "black"),
    strip.text = element_text(size = 11, face = "bold"),
    plot.title = element_text(hjust = 0.5, size = 13, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
    axis.text.y = element_text(size = 10),
    axis.title = element_text(size = 12, face = "bold"),
    legend.position = "none"
  ) +
  ggpubr::stat_compare_means(method = "wilcox.test", 
                             comparisons = list(c("Technical replicates", "Between samples (same type)"),
                                                c("Technical replicates", "Between samples (different type)")),
                             label = "p.signif")


# Save plot
ggsave("../output/Figure_S3/Supplementary_Figure_S3.pdf", 
       plot_distnances_replicates, width = 12, height = 6, dpi = 300)

cat("✓ Figure S3 saved\n\n")

##############################################
#         TECHNICAL REPLICATE MERGING        #
#            WITH RAREFACTION PREP           #
##############################################

##############################################
# STEP 1: MERGE TECHNICAL REPLICATES
##############################################

cat("STEP 1: Merging technical replicates...\n")

# Function to merge technical replicates
merge_technical_replicates <- function(asv_occurrence, asvs_to_remove, metadata, dataset_name) {
  
  # Remove flagged ASVs
  asvs_to_keep <- setdiff(rownames(asv_occurrence), asvs_to_remove)
  
  merged_asv <- asv_occurrence[asvs_to_keep, ] %>%
    t() %>%
    as.data.frame() %>%
    tibble::rownames_to_column("Purified_PCR_Product_Voucher") %>%
    # Remove negative controls
    dplyr::anti_join(metadata %>% 
                       dplyr::filter(Sample_type == "Negative") %>%
                       dplyr::select(Purified_PCR_Product_Voucher),
                     by = "Purified_PCR_Product_Voucher") %>%
    # Link to DNA extraction voucher
    dplyr::inner_join(METADATA %>% 
                        dplyr::select(Purified_PCR_Product_Voucher, DNA_Extraction_Voucher),
                      by = "Purified_PCR_Product_Voucher") %>%
    dplyr::select(-Purified_PCR_Product_Voucher) %>%
    # Sum technical replicates by DNA extraction voucher
    dplyr::group_by(DNA_Extraction_Voucher) %>%
    dplyr::summarize(dplyr::across(.cols = everything(), sum)) %>%
    dplyr::ungroup() %>%
    tibble::column_to_rownames("DNA_Extraction_Voucher") %>%
    # Transpose back to ASV × Sample format
    t() %>%
    as.data.frame()
  
  cat("  ", dataset_name, "merged:\n")
  cat("    ASVs:", nrow(merged_asv), "\n")
  cat("    Samples:", ncol(merged_asv), "\n")
  
  return(merged_asv)
}

# Get ASVs to remove for both datasets
euk_asvs_to_remove <- unique(c(
  euk_rare_flagged$ASV_ID,
  euk_taxonomy_flagged$ASV_ID,
  euk_contam_flagged$ASV_ID
))

pro_asvs_to_remove <- unique(c(
  pro_rare_flagged$ASV_ID,
  pro_taxonomy_flagged$ASV_ID,
  pro_contam_flagged$ASV_ID
))

# Merge technical replicates
euk.asv.merged <- merge_technical_replicates(
  EUK_ASV_OCCURENCE, euk_asvs_to_remove, METADATA.decontam.euk, "Eukaryotes"
)

pro.asv.merged <- merge_technical_replicates(
  PRO_ASV_OCCURENCE, pro_asvs_to_remove, METADATA.decontam.pro, "Prokaryotes"
)

cat("\nTechnical replicates merged successfully!\n\n")

##############################################
# STEP 2: PREPARE METADATA FOR MERGED SAMPLES
##############################################

cat("STEP 2: Preparing metadata for merged samples...\n")

# Create metadata for merged samples (one row per DNA extraction)
prepare_merged_metadata <- function(merged_asv, metadata_full) {
  
  sample_ids <- colnames(merged_asv)
  
  # Get unique metadata for each DNA extraction voucher
  merged_metadata <- metadata_full %>%
    dplyr::filter(DNA_Extraction_Voucher %in% sample_ids) %>%
    dplyr::select(DNA_Extraction_Voucher, Sample_type, Site, Depth, Depth_cat, Substrate) %>%
    dplyr::distinct() %>%
    # Rename for consistency
    dplyr::rename(Extraction_Voucher = DNA_Extraction_Voucher)
  
  # Check for duplicates
  if (any(duplicated(merged_metadata$Extraction_Voucher))) {
    cat("  WARNING: Duplicate extraction vouchers found in metadata!\n")
    duplicates <- merged_metadata$Extraction_Voucher[duplicated(merged_metadata$Extraction_Voucher)]
    cat("  Duplicates:", paste(duplicates, collapse = ", "), "\n")
  }
  
  # Ensure all samples in ASV table have metadata
  missing_metadata <- setdiff(sample_ids, merged_metadata$Extraction_Voucher)
  if (length(missing_metadata) > 0) {
    cat("  WARNING: Samples without metadata:", length(missing_metadata), "\n")
  }
  
  return(merged_metadata)
}

# Prepare metadata for both datasets
EUK_META_FORMATED <- prepare_merged_metadata(euk.asv.merged, METADATA)
PRO_META_FORMATED <- prepare_merged_metadata(pro.asv.merged, METADATA)

##############################################
# STEP 3: PREPARE DATA FOR RAREFACTION
##############################################

# Function to prepare rarefaction data
prepare_rarefaction_data <- function(asv_merged, metadata, dataset_name) {
  
  # Transpose ASV table so samples are rows, ASVs are columns
  asv_transposed <- asv_merged %>%
    t() %>%
    as.data.frame() %>%
    tibble::rownames_to_column("Extraction_Voucher")
  
  # Join with metadata to get sample type
  rare_data <- asv_transposed %>%
    dplyr::left_join(
      metadata %>% 
        dplyr::select(Extraction_Voucher, Sample_type) %>% 
        dplyr::distinct(),
      by = "Extraction_Voucher"
    )
  
  # Check for samples without metadata
  samples_without_metadata <- rare_data %>%
    dplyr::filter(is.na(Sample_type)) %>%
    dplyr::pull(Extraction_Voucher)
  
  if (length(samples_without_metadata) > 0) {
    cat("  WARNING:", dataset_name, "- Samples without metadata:", 
        length(samples_without_metadata), "\n")
    cat("  Removing these samples from rarefaction data\n")
    rare_data <- rare_data %>% dplyr::filter(!is.na(Sample_type))
  }
  
  # Set row names and move Sample_type to first column
  rare_data <- rare_data %>%
    tibble::column_to_rownames("Extraction_Voucher") %>%
    dplyr::select(Sample_type, everything())
  
  # Calculate summary statistics
  total_reads <- rare_data %>% 
    dplyr::select(-Sample_type) %>% 
    rowSums()
  
  asv_richness <- rare_data %>% 
    dplyr::select(-Sample_type) %>% 
    apply(1, function(x) sum(x > 0))
  
  cat("  ", dataset_name, "rarefaction data:\n")
  cat("    Samples:", nrow(rare_data), "\n")
  cat("    ASVs:", ncol(rare_data) - 1, "\n")
  cat("    Read depth range:", min(total_reads), "-", max(total_reads), "\n")
  cat("    Mean read depth:", round(mean(total_reads), 0), "\n")
  cat("    ASV richness range:", min(asv_richness), "-", max(asv_richness), "\n\n")
  
  return(rare_data)
}

# Create rarefaction datasets
euk_rare_data <- prepare_rarefaction_data(euk.asv.merged, EUK_META_FORMATED, "Eukaryotes")
pro_rare_data <- prepare_rarefaction_data(pro.asv.merged, PRO_META_FORMATED, "Prokaryotes")

##############################################
#             RAREFACTION CURVES             #
##############################################

cat("Creating Figure S4: Rarefaction curves...\n")

# Enhanced rarefaction function
create_enhanced_rarefaction <- function(rare_data, dataset_name) {
  
  # Separate metadata from community data
  sample_types <- rare_data$Sample_type
  community_data <- rare_data %>% dplyr::select(-Sample_type)
  
  # Define colors for sample types
  sample_colors <- c(
    "single_cell" = "#E31A1C",
    "sediment" = "#1F78B4",
    "filter" = "#33A02C"
  )
  
  rare_results <- list()
  
  cat("  Processing", dataset_name, "samples...\n")
  
  for(i in 1:nrow(community_data)) {
    sample_name <- rownames(community_data)[i]
    sample_type <- sample_types[i]
    sample_data <- as.numeric(community_data[i,])
    sample_data <- sample_data[sample_data > 0]
    
    total_reads <- sum(sample_data)
    
    max_step <- min(total_reads, 200000)
    step_size <- max(100, round(max_step/100))
    steps <- seq(step_size, max_step, by = step_size)
    
    # Calculate rarefied richness
    richness_values <- sapply(steps, function(n) {
      if(n >= total_reads) {
        return(length(sample_data))
      } else {
        tryCatch({
          rarefy(sample_data, n)
        }, error = function(e) NA)
      }
    })
    
    rare_results[[i]] <- data.frame(
      Sample = sample_name,
      Sample_type = sample_type,
      Depth = steps,
      Richness = richness_values,
      Total_reads = total_reads
    ) %>% dplyr::filter(!is.na(Richness))
  }
  
  # Combine all results
  rare_combined <- do.call(rbind, rare_results)
  
  cat("    Rarefaction calculated for", length(unique(rare_combined$Sample)), "samples\n")
  
  # Create the plot
  rare_plot <- ggplot(rare_combined, aes(x = Depth, y = Richness, color = Sample_type, group = Sample)) +
    geom_line(alpha = 0.6, linewidth = 0.5) +
    scale_color_manual(
      values = sample_colors,
      labels = c("filter" = "Seawater", "sediment" = "Sediment", "single_cell" = "Foraminifera"),
      name = "Sample Type"
    ) +
    labs(
      title = paste("Rarefaction Curves -", dataset_name),
      x = "Sequencing Depth (reads)",
      y = "ASV Richness"
    ) +
    theme_minimal() +
    theme(
      panel.border = element_rect(color = "black", fill = NA, linewidth = 0.8),
      panel.grid.minor = element_blank(),
      legend.position = "bottom",
      plot.title = element_text(hjust = 0.5, size = 13, face = "bold"),
      axis.text = element_text(size = 10),
      axis.title = element_text(size = 11, face = "bold"),
      legend.title = element_text(size = 11, face = "bold"),
      legend.text = element_text(size = 10)
    ) +
    scale_x_continuous(labels = scales::comma_format()) +
    guides(color = guide_legend(override.aes = list(linewidth = 2, alpha = 1)))
  
  return(list(
    plot = rare_plot,
    data = rare_combined
  ))
}

##############################################
#       GENERATE RAREFACTION CURVES          #
##############################################

# Create rarefaction curves
euk_rare_result <- create_enhanced_rarefaction(euk_rare_data, "Eukaryotes")
pro_rare_result <- create_enhanced_rarefaction(pro_rare_data, "Prokaryotes")

# Combine plots
combined_rarefaction <- plot_grid(
  euk_rare_result$plot, 
  pro_rare_result$plot,
  ncol = 1, nrow = 2,
  align = "hv",
  labels = c("A", "B")
)

# Save plot
ggsave("../output/Figure_S4/Supplementary_Figure_S4.pdf", 
       combined_rarefaction,
       width = 10, height = 12, dpi = 300)

cat("✓ Figure S4 saved\n\n")

##############################################
# RAREFACTION SATURATION ANALYSIS (FIG S5)
##############################################

cat("Creating Figure S5: Saturation analysis...\n")

# Function to calculate saturation metrics
calculate_saturation_metrics <- function(rare_data, rare_result_data, dataset_name) {
  
  # Calculate total reads and richness per sample
  sample_stats <- rare_data %>%
    tibble::rownames_to_column("Sample_ID") %>%
    dplyr::mutate(
      Total_reads = rowSums(dplyr::select(., -Sample_ID, -Sample_type)),
      Total_ASVs = rowSums(dplyr::select(., -Sample_ID, -Sample_type) > 0)
    ) %>%
    dplyr::select(Sample_ID, Sample_type, Total_reads, Total_ASVs)
  
  cat("  Calculating saturation metrics for", dataset_name, "...\n")
  
  # Calculate saturation metrics per sample
  saturation_metrics <- rare_result_data %>%
    dplyr::group_by(Sample) %>%
    dplyr::arrange(Depth) %>%
    dplyr::summarize(
      # Metric 1: Slope of last 10 points
      Final_slope = if(n() >= 2) {
        tryCatch({
          tail_data <- tail(dplyr::cur_data(), 10)
          if(nrow(tail_data) >= 2) {
            lm(Richness ~ Depth, data = tail_data)$coefficients[2]
          } else {
            NA
          }
        }, error = function(e) NA)
      } else {
        NA
      },
      
      # Metric 2: Percentage of asymptote reached
      Max_richness = max(Richness, na.rm = TRUE),
      Final_richness = dplyr::last(Richness),
      Pct_asymptote = (Final_richness / Max_richness) * 100,
      
      # Metric 3: Richness gain in last 20%
      Total_depth = max(Depth),
      Depth_80pct = Total_depth * 0.8,
      Richness_at_80pct = Richness[which.min(abs(Depth - Depth_80pct))],
      Richness_gain_final_20pct = Final_richness - Richness_at_80pct,
      Pct_gain_final_20pct = (Richness_gain_final_20pct / Final_richness) * 100,
      
      .groups = "drop"
    )
  
  # Rename Sample to Sample_ID
  colnames(saturation_metrics)[colnames(saturation_metrics) == "Sample"] <- "Sample_ID"
  
  # Combine with sample stats
  saturation_summary <- sample_stats %>%
    dplyr::left_join(saturation_metrics, by = "Sample_ID")
  
  # Determine data-driven thresholds
  slope_quantiles <- quantile(abs(saturation_summary$Final_slope), 
                              probs = c(0.33, 0.67), na.rm = TRUE)
  
  # Classify saturation
  saturation_summary <- saturation_summary %>%
    dplyr::mutate(
      Slope_status = dplyr::case_when(
        is.na(Final_slope) ~ "Unknown",
        abs(Final_slope) < slope_quantiles[1] ~ "Low slope",
        abs(Final_slope) < slope_quantiles[2] ~ "Medium slope",
        TRUE ~ "High slope"
      ),
      
      Gain_status = dplyr::case_when(
        is.na(Pct_gain_final_20pct) ~ "Unknown",
        Pct_gain_final_20pct < 5 ~ "Low gain (<5%)",
        Pct_gain_final_20pct < 10 ~ "Medium gain (5-10%)",
        TRUE ~ "High gain (>10%)"
      ),
      
      Saturation_status = dplyr::case_when(
        is.na(Final_slope) | is.na(Pct_gain_final_20pct) ~ "Unknown",
        Slope_status == "Low slope" & Pct_gain_final_20pct < 5 ~ "Well saturated",
        Slope_status == "High slope" | Pct_gain_final_20pct > 10 ~ "Poorly saturated",
        TRUE ~ "Moderately saturated"
      )
    )
  
  # Summary by sample type
  summary_by_type <- saturation_summary %>%
    dplyr::group_by(Sample_type) %>%
    dplyr::summarize(
      n_samples = n(),
      mean_reads = round(mean(Total_reads), 0),
      sd_reads = round(sd(Total_reads), 0),
      min_reads = min(Total_reads),
      max_reads = max(Total_reads),
      mean_asvs = round(mean(Total_ASVs), 1),
      sd_asvs = round(sd(Total_ASVs), 1),
      min_asvs = min(Total_ASVs),
      max_asvs = max(Total_ASVs),
      mean_slope = format(mean(abs(Final_slope), na.rm = TRUE), scientific = TRUE),
      median_slope = format(median(abs(Final_slope), na.rm = TRUE), scientific = TRUE),
      mean_pct_gain = round(mean(Pct_gain_final_20pct, na.rm = TRUE), 1),
      median_pct_gain = round(median(Pct_gain_final_20pct, na.rm = TRUE), 1),
      well_saturated = sum(Saturation_status == "Well saturated"),
      moderately_saturated = sum(Saturation_status == "Moderately saturated"),
      poorly_saturated = sum(Saturation_status == "Poorly saturated"),
      .groups = "drop"
    ) %>%
    dplyr::mutate(Dataset = dataset_name, .before = 1)
  
  return(list(
    per_sample = saturation_summary %>% dplyr::mutate(Dataset = dataset_name, .before = 1),
    by_type = summary_by_type,
    thresholds = slope_quantiles
  ))
}

# Calculate saturation metrics
euk_saturation <- calculate_saturation_metrics(euk_rare_data, euk_rare_result$data, "Eukaryotes")
pro_saturation <- calculate_saturation_metrics(pro_rare_data, pro_rare_result$data, "Prokaryotes")

# Combine summaries
all_saturation_by_type <- rbind(euk_saturation$by_type, pro_saturation$by_type)
all_saturation_per_sample <- rbind(euk_saturation$per_sample, pro_saturation$per_sample)

# Prepare data for plotting
saturation_plot_data <- all_saturation_per_sample %>%
  dplyr::mutate(
    Sample_type = factor(Sample_type, 
                         levels = c("filter", "sediment", "single_cell"),
                         labels = c("Seawater", "Sediment", "Foraminifera")),
    Saturation_status = factor(Saturation_status,
                               levels = c("Well saturated", "Moderately saturated", 
                                          "Poorly saturated", "Unknown"))
  )

# PLOT 1: Slope distribution
plot_slope_distribution <- ggplot(saturation_plot_data %>% dplyr::filter(!is.na(Final_slope)), 
                                  aes(x = Sample_type, y = abs(Final_slope), 
                                      fill = Sample_type)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.4, size = 1.5) +
  scale_fill_manual(
    values = c("Seawater" = "#33A02C", "Sediment" = "#1F78B4", 
               "Foraminifera" = "#E31A1C")
  ) +
  scale_y_log10() +
  facet_wrap(~Dataset) +
  labs(
    title = "Rarefaction Curve Slope at Final Sequencing Depth",
    subtitle = "Lower values indicate better saturation (log scale)",
    x = "Sample Type",
    y = "Absolute Slope"
  ) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.8),
    strip.background = element_rect(fill = "grey90", color = "black"),
    strip.text = element_text(size = 11, face = "bold"),
    plot.title = element_text(hjust = 0.5, size = 13, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    axis.text.x = element_text(angle = 0, hjust = 0.5, size = 10),
    axis.text.y = element_text(size = 10),
    axis.title = element_text(size = 11, face = "bold"),
    legend.position = "none"
  )

# PLOT 2: Richness gain
plot_richness_gain <- ggplot(saturation_plot_data %>% dplyr::filter(!is.na(Pct_gain_final_20pct)), 
                             aes(x = Sample_type, y = Pct_gain_final_20pct, 
                                 fill = Sample_type)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.4, size = 1.5) +
  geom_hline(yintercept = 5, linetype = "dashed", color = "darkgreen", linewidth = 0.8) +
  geom_hline(yintercept = 10, linetype = "dashed", color = "orange", linewidth = 0.8) +
  scale_fill_manual(
    values = c("Seawater" = "#33A02C", "Sediment" = "#1F78B4", 
               "Foraminifera" = "#E31A1C")
  ) +
  facet_wrap(~Dataset) +
  labs(
    title = "Richness Gain in Final 20% of Sequencing Depth",
    subtitle = "Lower values indicate approaching asymptote (<5% = good, >10% = poor)",
    x = "Sample Type",
    y = "Percentage of Total Richness (%)"
  ) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.8),
    strip.background = element_rect(fill = "grey90", color = "black"),
    strip.text = element_text(size = 11, face = "bold"),
    plot.title = element_text(hjust = 0.5, size = 13, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    axis.text.x = element_text(angle = 0, hjust = 0.5, size = 10),
    axis.text.y = element_text(size = 10),
    axis.title = element_text(size = 11, face = "bold"),
    legend.position = "none"
  )

# Combine saturation plots
combined_saturation_plots <- plot_grid( 
  plot_slope_distribution,
  plot_richness_gain,
  ncol = 2, nrow = 1,
  labels = c("A", "B")
)

# Save plots
ggsave("../output/Figure_S5/Supplementary_figure_S5.pdf", 
       combined_saturation_plots, width = 14, height = 6, dpi = 300)

cat("✓ Figure S5 saved\n\n")

##############################################
#         DATA PREPARATION FOR ANALYSIS     #
##############################################

cat("Preparing data for downstream analyses...\n")

# Create taxonomy objects
EUK_TAX <- EUK_TAXONOMY
PRO_TAX <- PRO_TAXONOMY
EUK_TAX_BOOT <- EUK_TAXONOMY_BOOT
PRO_TAX_BOOT <- PRO_TAXONOMY_BOOT

# Filter bootstrap tables to only include ASVs present in cleaned datasets
euk_boot_filtered <- EUK_TAX_BOOT %>%
  tibble::rownames_to_column(var = "ASV_ID") %>%
  dplyr::filter(ASV_ID %in% rownames(euk.asv.merged))

pro_boot_filtered <- PRO_TAX_BOOT %>%
  tibble::rownames_to_column(var = "ASV_ID") %>%
  dplyr::filter(ASV_ID %in% rownames(pro.asv.merged))

# Reshape bootstrap data to long format
euk_boot_long <- euk_boot_filtered %>%
  dplyr::select(ASV_ID, Kingdom, Supergroup, Division, Class, Order, Family, Genus, Species) %>%
  tidyr::gather(Taxonomic_Level, Bootstrap_Value, -ASV_ID) %>%
  dplyr::mutate(Taxonomic_Level = factor(Taxonomic_Level, 
                                         levels = c("Kingdom", "Supergroup", "Division", "Class", 
                                                    "Order", "Family", "Genus", "Species")),
                Dataset = "Eukaryotes")

pro_boot_long <- pro_boot_filtered %>%
  dplyr::select(ASV_ID, Kingdom, Phylum, Class, Order, Family, Genus) %>%
  tidyr::gather(Taxonomic_Level, Bootstrap_Value, -ASV_ID) %>%
  dplyr::mutate(Taxonomic_Level = factor(Taxonomic_Level, 
                                         levels = c("Kingdom", "Phylum", "Class", 
                                                    "Order", "Family", "Genus")),
                Dataset = "Prokaryotes")

# Combine data
boot_combined <- dplyr::bind_rows(euk_boot_long, pro_boot_long)

# Function to flag low-confidence taxonomy
flag_low_confidence_taxonomy <- function(taxonomy_table, bootstrap_table, threshold = 50) {
  
  tax_df <- as.data.frame(taxonomy_table)
  boot_df <- as.data.frame(bootstrap_table)
  
  tax_levels <- colnames(tax_df)
  
  for (level in tax_levels) {
    if (level %in% colnames(boot_df)) {
      low_confidence <- boot_df[[level]] < threshold
      low_confidence[is.na(low_confidence)] <- TRUE
      tax_df[[level]][low_confidence] <- "Unclassified"
    }
  }
  
  return(tax_df)
}

# Apply flagging
EUK_TAX_FLAGGED <- flag_low_confidence_taxonomy(EUK_TAX, EUK_TAX_BOOT, threshold = 50)
PRO_TAX_FLAGGED <- flag_low_confidence_taxonomy(PRO_TAX, PRO_TAX_BOOT, threshold = 50)

# Update taxonomy objects
EUK_TAX <- EUK_TAX_FLAGGED
PRO_TAX <- PRO_TAX_FLAGGED

# Function to prepare proportional community data
prepare_community_data <- function(asv_table, metadata_formatted, taxonomy_table) {
  asv_table %>%
    as.matrix() %>% 
    prop.table(margin = 2) %>% 
    as.data.frame() %>% 
    tibble::rownames_to_column(var = "ASV_ID") %>%
    tidyr::gather(Extraction_Voucher, proportion_ASV, -ASV_ID) %>% 
    dplyr::filter(proportion_ASV > 0) %>% 
    dplyr::inner_join(metadata_formatted, by = "Extraction_Voucher") %>% 
    dplyr::inner_join(taxonomy_table %>% tibble::rownames_to_column(var = "ASV_ID"), by = "ASV_ID")
}

# Prepare community data
ll.all.euk <- prepare_community_data(euk.asv.merged, EUK_META_FORMATED, EUK_TAX)
ll.all.pro <- prepare_community_data(pro.asv.merged, PRO_META_FORMATED, PRO_TAX)

cat("✓ Data preparation complete\n\n")

##############################################
#              FIGURE 2 GENERATION          #
#     (Community Composition Overview)      #
##############################################

##############################################
#     BLOCK 1: UPSET PLOT ANALYSIS          #
##############################################

# Function to prepare UpSet plot data
prepare_upset_data <- function(community_data, group_var = "Sample_type") {
  community_data %>% 
    dplyr::select(dplyr::all_of(group_var), ASV_ID) %>% 
    dplyr::distinct() %>% 
    dplyr::mutate(Presence = 1) %>% 
    tidyr::spread(key = !!sym(group_var), value = Presence, fill = 0) %>% 
    tibble::column_to_rownames("ASV_ID") %>%
    as.data.frame() %>%
    mutate_all(as.numeric)
}

# Create UpSet data for both datasets
Data.euk.upset <- prepare_upset_data(ll.all.euk, "Sample_type")
Data.pro.upset <- prepare_upset_data(ll.all.pro, "Sample_type")

# Function to create standardized UpSet plots
create_upset_plot <- function(upset_data, dataset_name, n_sets = 10) {
  upset(upset_data,
        nsets = n_sets, 
        number.angles = 30, 
        point.size = 3.5, 
        line.size = 2, 
        mainbar.y.label = paste("N ASVs -", dataset_name), 
        sets.x.label = "ASVs per sample type", 
        text.scale = c(1.5, 1.5, 1, 1, 2, 1), 
        order.by = "freq")
}

# Create UpSet plots
Upset_euk <- create_upset_plot(Data.euk.upset, "Eukaryotes")
Upset_pro <- create_upset_plot(Data.pro.upset, "Prokaryotes")

##############################################
#  BLOCK 2: TAXONOMIC COMPOSITION ANALYSIS  #
##############################################
# Function to create simplified taxonomic groups
create_simplified_taxonomy <- function(taxonomy_table, taxonomy_boot_table, dataset_type) {
  
  if (dataset_type == "eukaryotes") {
    # Eukaryotic groupings based on ecological relevance
    taxonomy_combined <- taxonomy_table %>%
      tibble::rownames_to_column(var = "ASV_ID") %>%
      dplyr::left_join(taxonomy_boot_table %>%
                         tibble::rownames_to_column(var = "ASV_ID") %>%
                         dplyr::select(ASV_ID, Kingdom, Supergroup, Division, Class) %>%
                         dplyr::rename("Kingdom_boot" = "Kingdom",
                                              "Supergroup_boot" = "Supergroup", 
                                              "Division_boot" = "Division",
                                              "Class_boot" = "Class"), 
                       by = "ASV_ID")
    
    # Create taxonomic groups
    simplified_tax <- taxonomy_combined %>%
      dplyr::mutate(Taxonomic_group = case_when(
        Class == "Bacillariophyta" & Class_boot >= 80 ~ "Bacillariophyta",
        Supergroup == "Alveolata" ~ "Alveolata", 
        Supergroup == "Opisthokonta" ~ "Opisthokonta",
        Supergroup %in% c("Archaeplastida", "Archaeplastida:plas") ~ "Archaeplastida",
        Class_boot < 80 ~ "Unclassified",
        TRUE ~ "Others"
      )) %>%
      dplyr::select(ASV_ID, Taxonomic_group)
    
  } else if (dataset_type == "prokaryotes") {
    # Prokaryotic groupings based on major phyla
    taxonomy_combined <- taxonomy_table %>%
      tibble::rownames_to_column(var = "ASV_ID") %>%
      dplyr::left_join(taxonomy_boot_table %>%
                         tibble::rownames_to_column(var = "ASV_ID") %>%
                         dplyr::select(ASV_ID, Kingdom, Phylum, Class) %>%
                         dplyr::rename("Kingdom_boot" = "Kingdom",
                                              "Phylum_boot" = "Phylum",
                                              "Class_boot" = "Class"),
                       by = "ASV_ID")
    
    # Create taxonomic groups
    simplified_tax <- taxonomy_combined %>%
      dplyr::mutate(Taxonomic_group = case_when(
        Order == "Chloroplast" ~ "Chloroplast",
        Phylum == "Proteobacteria" & Class_boot >= 80 ~ "Proteobacteria",
        Phylum == "Bacteroidota" & Class_boot >= 80 ~ "Bacteroidota", 
        Phylum == "Planctomycetota" & Class_boot >= 80 ~ "Planctomycetota",
        Class_boot < 80 ~ "Unclassified",
        TRUE ~ "Others"
      )) %>%
      dplyr::select(ASV_ID, Taxonomic_group)
  }
  
  return(simplified_tax)
}

# Create simplified taxonomies
TAX_EUK_SIMPLIFIED <- create_simplified_taxonomy(EUK_TAX, EUK_TAX_BOOT, "eukaryotes")
TAX_PRO_SIMPLIFIED <- create_simplified_taxonomy(PRO_TAX, PRO_TAX_BOOT, "prokaryotes")

# Apply simplified taxonomy to community data
apply_simplified_taxonomy <- function(community_data, simplified_tax) {
  community_data %>%
    dplyr::left_join(simplified_tax, by = "ASV_ID") %>%
    dplyr::group_by(Extraction_Voucher, Site, Depth_cat, Sample_type, Substrate, Taxonomic_group) %>%
    dplyr::summarize(proportion_ASV = sum(proportion_ASV, na.rm = TRUE), .groups = "drop")
}

# Apply to both datasets
euk.asv.prop.tax.simp.plot <- apply_simplified_taxonomy(ll.all.euk, TAX_EUK_SIMPLIFIED)
pro.asv.prop.tax.simp.plot <- apply_simplified_taxonomy(ll.all.pro, TAX_PRO_SIMPLIFIED)

# Set factor levels for consistent plotting order
euk.asv.prop.tax.simp.plot$Taxonomic_group <- factor(
  euk.asv.prop.tax.simp.plot$Taxonomic_group, 
  levels = c("Bacillariophyta", "Alveolata", "Archaeplastida", "Opisthokonta", "Others", "Unclassified")
)

pro.asv.prop.tax.simp.plot$Taxonomic_group <- factor(
  pro.asv.prop.tax.simp.plot$Taxonomic_group, 
  levels = c("Proteobacteria", "Bacteroidota", "Planctomycetota", "Chloroplast", "Others", "Unclassified")
)

# Rename sample types for better labels
euk.asv.prop.tax.simp.plot <- euk.asv.prop.tax.simp.plot %>%
  dplyr::mutate(Sample_type = factor(Sample_type,
                                     levels = c("single_cell", "sediment", "filter"),
                                     labels = c("Foraminifera", "Sediment", "Seawater")))

pro.asv.prop.tax.simp.plot <- pro.asv.prop.tax.simp.plot %>%
  dplyr::mutate(Sample_type = factor(Sample_type,
                                     levels = c("single_cell", "sediment", "filter"),
                                     labels = c("Foraminifera", "Sediment", "Seawater")))


##############################################
#      BLOCK 3: ALPHA DIVERSITY ANALYSIS    #
##############################################
# Function to calculate alpha diversity metrics
calculate_alpha_diversity <- function(asv_table, metadata_formatted, diversity_index = "invsimpson") {
  # Calculate diversity index
  diversity_values <- diversity(asv_table %>% as.matrix() %>% t(), index = diversity_index) %>% 
    as.data.frame() %>% 
    tibble::rownames_to_column(var = "Extraction_Voucher") %>% 
    dplyr::rename("Diversity" = ".")
  
  # Join with metadata
  diversity_data <- diversity_values %>%
    dplyr::inner_join(metadata_formatted, by = "Extraction_Voucher")
  
  return(diversity_data)
}

# Calculate inverse Simpson diversity for both datasets
simpson_euks <- calculate_alpha_diversity(euk.asv.merged, EUK_META_FORMATED, "invsimpson")
simpson_proks <- calculate_alpha_diversity(pro.asv.merged, PRO_META_FORMATED, "invsimpson")

# Rename diversity columns for clarity
simpson_euks <- simpson_euks %>% 
  dplyr::rename("InvSimpson" = "Diversity") %>%
  dplyr::mutate(Sample_type = factor(Sample_type,
                                     levels = c("single_cell", "sediment", "filter"),
                                     labels = c("Foraminifera", "Sediment", "Seawater")))

simpson_proks <- simpson_proks %>% 
  dplyr::rename("InvSimpson" = "Diversity") %>%
  dplyr::mutate(Sample_type = factor(Sample_type,
                                     levels = c("single_cell", "sediment", "filter"),
                                     labels = c("Foraminifera", "Sediment", "Seawater")))

# Statistical analysis of diversity patterns (focusing on foraminifera only)
cat("Performing ANOVA on foraminiferal diversity patterns...\n")

# ANOVA for inverse Simpson
res.aov.euk.simpson <- aov(InvSimpson ~ Site * Depth_cat * Substrate, 
                           data = simpson_euks %>% dplyr::filter(Sample_type == "Foraminifera"))
res.aov.pro.simpson <- aov(InvSimpson ~ Site * Depth_cat * Substrate, 
                           data = simpson_proks %>% dplyr::filter(Sample_type == "Foraminifera"))

# Display results
cat("Eukaryotic diversity ANOVA (Inverse Simpson):\n")
print(summary(res.aov.euk.simpson))

cat("\nProkaryotic diversity ANOVA (Inverse Simpson):\n")
print(summary(res.aov.pro.simpson))

##############################################
#                                            #
#      BLOCK 4: BETA DIVERSITY ANALYSIS      #
#                                            #
##############################################

cat("Performing beta diversity analyses...\n")

# Function to prepare data for multivariate analyses (FIXED WITH ROW NAMES)
prepare_multivariate_data <- function(asv_table, metadata_formatted) {
  # Convert to proportions
  community_matrix <- asv_table %>% 
    t() %>% 
    as.matrix() %>% 
    prop.table(margin = 1) %>%  # Convert to proportions by sample
    as.data.frame()
  
  # CRITICAL: Get sample IDs from rownames
  sample_ids <- rownames(community_matrix)
  
  # Get metadata in the SAME ORDER as community matrix rows
  meta_subset <- metadata_formatted %>%
    dplyr::filter(Extraction_Voucher %in% sample_ids) %>%
    dplyr::arrange(match(Extraction_Voucher, sample_ids)) %>%  # CRITICAL: Match order
    dplyr::mutate(Sample_type = factor(Sample_type,
                                       levels = c("single_cell", "sediment", "filter"),
                                       labels = c("Foraminifera", "Sediment", "Seawater")))
  
  # Verify order matches
  if (!all(meta_subset$Extraction_Voucher == sample_ids)) {
    stop("ERROR: Sample order mismatch between community matrix and metadata!")
  }
  
  # Add metadata columns to community matrix (preserving row order)
  community_matrix$Extraction_Voucher <- sample_ids
  community_matrix$Site <- meta_subset$Site
  community_matrix$Depth_cat <- meta_subset$Depth_cat
  community_matrix$Sample_type <- meta_subset$Sample_type
  community_matrix$Substrate <- meta_subset$Substrate
  
  return(community_matrix)
}

# Prepare data for both datasets
euk_multivariate <- prepare_multivariate_data(euk.asv.merged, EUK_META_FORMATED)
pro_multivariate <- prepare_multivariate_data(pro.asv.merged, PRO_META_FORMATED)

cat("Multivariate data prepared:\n")
cat("  Eukaryotes:", nrow(euk_multivariate), "samples\n")
cat("  Prokaryotes:", nrow(pro_multivariate), "samples\n")

# Verify sample type distribution
cat("\nSample type distribution in multivariate data:\n")
cat("Eukaryotes:\n")
print(table(euk_multivariate$Sample_type))
cat("Prokaryotes:\n")
print(table(pro_multivariate$Sample_type))
cat("\n")

# Function to perform comprehensive beta diversity analysis (FIXED)
perform_beta_analysis <- function(multivariate_data, dataset_name) {
  
  # Define metadata column names
  metadata_colnames <- c("Extraction_Voucher", "Site", "Depth_cat", "Sample_type", "Substrate")
  
  # Get ASV column names (everything that's NOT metadata)
  asv_colnames <- setdiff(names(multivariate_data), metadata_colnames)
  
  # Extract community matrix (ASVs only) - KEEP AS DATA FRAME WITH ROW NAMES
  community_matrix <- multivariate_data %>%
    dplyr::select(dplyr::all_of(asv_colnames))
  
  # Extract metadata IN THE SAME ORDER
  metadata_subset <- multivariate_data %>%
    dplyr::select(dplyr::all_of(metadata_colnames))
  
  # CRITICAL: Set row names to track samples
  rownames(community_matrix) <- metadata_subset$Extraction_Voucher
  rownames(metadata_subset) <- metadata_subset$Extraction_Voucher
  
  # Verify dimensions match
  if (nrow(community_matrix) != nrow(metadata_subset)) {
    stop("ERROR: Dimension mismatch between community and metadata!")
  }
  
  cat(paste("  Community matrix:", nrow(community_matrix), "samples ×", 
            ncol(community_matrix), "ASVs\n"))
  
  # 1. NMDS Ordination (k=2 for visualization)
  cat(paste("  Running NMDS for", dataset_name, "...\n"))
  nmds_result <- metaMDS(community_matrix, distance = "bray", k = 2, try = 100, trace = FALSE)
  
  # CRITICAL: Extract NMDS scores WITH row names preserved
  nmds_scores <- as.data.frame(vegan::scores(nmds_result)$sites)
  
  # CRITICAL: Verify row names match before joining
  if (!all(rownames(nmds_scores) == rownames(metadata_subset))) {
    stop("ERROR: NMDS scores and metadata row order mismatch!")
  }
  
  # Add metadata to NMDS scores (now safe because row order matches)
  nmds_scores$Extraction_Voucher <- rownames(nmds_scores)
  nmds_scores$Site <- metadata_subset$Site
  nmds_scores$Depth_cat <- metadata_subset$Depth_cat
  nmds_scores$Sample_type <- metadata_subset$Sample_type
  nmds_scores$Substrate <- metadata_subset$Substrate
  
  # Verify no mixing occurred
  cat(paste("  Sample type distribution in NMDS scores:\n"))
  print(table(nmds_scores$Sample_type))
  
  # 2. ANOSIM - Test differences between sample types
  cat(paste("  Running ANOSIM for", dataset_name, "...\n"))
  anosim_result <- anosim(community_matrix, metadata_subset$Sample_type, 
                          distance = "bray", permutations = 999)
  
  # 3. Betadispersion - Test homogeneity of multivariate dispersions
  cat(paste("  Running betadispersion analysis for", dataset_name, "...\n"))
  bray_dist <- vegdist(community_matrix, method = "bray")
  betadisp_result <- betadisper(bray_dist, metadata_subset$Sample_type)
  betadisp_test <- permutest(betadisp_result, permutations = 999)
  
  cat(paste("  ✓", dataset_name, "analysis complete\n\n"))
  
  # Return results
  list(
    nmds = nmds_result,
    nmds_scores = nmds_scores,
    anosim = anosim_result,
    betadisp = betadisp_result,
    betadisp_test = betadisp_test,
    stress = nmds_result$stress
  )
}

# Perform beta diversity analyses
cat("Analyzing Eukaryotes:\n")
euk_beta <- perform_beta_analysis(euk_multivariate, "Eukaryotes")

cat("Analyzing Prokaryotes:\n")
pro_beta <- perform_beta_analysis(pro_multivariate, "Prokaryotes")

# Display results
cat("\n=== BETA DIVERSITY RESULTS ===\n")

cat("\nNMDS Stress values:\n")
cat("Eukaryotes:", round(euk_beta$stress, 3), "\n")
cat("Prokaryotes:", round(pro_beta$stress, 3), "\n")

cat("\nANOSIM Results:\n")
cat("Eukaryotes - R statistic:", round(euk_beta$anosim$statistic, 3), 
    ", p-value:", euk_beta$anosim$signif, "\n")
cat("Prokaryotes - R statistic:", round(pro_beta$anosim$statistic, 3), 
    ", p-value:", pro_beta$anosim$signif, "\n")

cat("\nBetadispersion Results:\n")
cat("Eukaryotes - F statistic:", round(euk_beta$betadisp_test$tab$F[1], 3), 
    ", p-value:", euk_beta$betadisp_test$tab$`Pr(>F)`[1], "\n")
cat("Prokaryotes - F statistic:", round(pro_beta$betadisp_test$tab$F[1], 3), 
    ", p-value:", pro_beta$betadisp_test$tab$`Pr(>F)`[1], "\n")

# Store NMDS scores for plotting
NMDS.scores.euks <- euk_beta$nmds_scores
NMDS.scores.pro  <- pro_beta$nmds_scores
S_NMDS_euk <- euk_beta$stress
S_NMDS_pro <- pro_beta$stress

##############################################
#         FIGURE 2 PANEL GENERATION          #
##############################################

cat("Creating Figure 2 panels...\n")

# Function to create plots with solid borders
create_bordered_theme <- function() {
  theme_minimal() +
    theme(
      panel.border = element_rect(color = "black", fill = NA, linewidth = 0.8),
      legend.text = element_text(size = 8),
      legend.title = element_text(size = 9),
      axis.text = element_text(size = 8),
      axis.title = element_text(size = 9),
      plot.title = element_text(size = 10, hjust = 0.5, face = "bold"),
      aspect.ratio = 1,
      legend.position = "none"
    )
}

# A2: Eukaryotic taxonomy
plot_A2 <- ggplot(euk.asv.prop.tax.simp.plot, 
                  aes(x = Sample_type, y = proportion_ASV, fill = Taxonomic_group)) +
  geom_boxplot() +
  coord_flip() +
  scale_fill_brewer(palette = "Dark2", name = "Eukaryotic groups") +
  labs(title = "A2", y = "Relative abundance") +
  create_bordered_theme() +
  theme(axis.title.y = element_blank())

# B2: Prokaryotic taxonomy  
plot_B2 <- ggplot(pro.asv.prop.tax.simp.plot, 
                  aes(x = Sample_type, y = proportion_ASV, fill = Taxonomic_group)) +
  geom_boxplot() +
  coord_flip() +
  scale_fill_brewer(palette = "Set2", name = "Prokaryotic groups") +
  labs(title = "B2", y = "Relative abundance") +
  create_bordered_theme() +
  theme(axis.title.y = element_blank())

# A3: Eukaryotic diversity
plot_A3 <- ggplot(simpson_euks, aes(x = Sample_type, y = InvSimpson, fill = Site)) +
  geom_boxplot() +
  coord_flip() +
  scale_fill_viridis_d(name = "Site") +
  labs(title = "A3", y = "Inverse Simpson") +
  create_bordered_theme() +
  theme(axis.title.y = element_blank())

# B3: Prokaryotic diversity
plot_B3 <- ggplot(simpson_proks, aes(x = Sample_type, y = InvSimpson, fill = Site)) +
  geom_boxplot() +
  coord_flip() +
  scale_fill_viridis_d(name = "Site") +
  labs(title = "B3", y = "Inverse Simpson") +
  create_bordered_theme() +
  theme(axis.title.y = element_blank())

# A4: Eukaryotic NMDS 
plot_A4 <- ggplot(NMDS.scores.euks, aes(x = NMDS1, y = NMDS2)) +
  geom_point(aes(fill = Site, shape = Sample_type, size = 4), 
             color = "black", stroke = 0.8) +
  scale_fill_viridis_d(name = "Site") +
  scale_shape_manual(
    values = c("Foraminifera" = 21, "Sediment" = 24, "Seawater" = 22),
    name = "Sample type"
  )  +
  labs(
    title = "A4: Eukaryotic beta diversity",
    subtitle = paste("Stress =", round(S_NMDS_euk, 3))
  ) +
  create_bordered_theme()

# B4: Prokaryotic NMDS
plot_B4 <- ggplot(NMDS.scores.pro, aes(x = NMDS1, y = NMDS2)) +
  geom_point(aes(fill = Site, shape = Sample_type, size = 4), 
             color = "black", stroke = 0.8) +
  scale_fill_viridis_d(name = "Site") +
  scale_shape_manual(
    values = c("Foraminifera" = 21, "Sediment" = 24, "Seawater" = 22),
    name = "Sample type"
  ) +
  labs(
    title = "B4: Prokaryotic beta diversity",
    subtitle = paste("Stress =", round(S_NMDS_pro, 3))
  ) +
  create_bordered_theme()

# Save individual panels
cat("Saving individual panels...\n")
ggsave("../output/Figure_2/Panel_A2_Euk_Taxonomy.pdf", plot_A2, width = 4, height = 4, dpi = 300)
ggsave("../output/Figure_2/Panel_B2_Pro_Taxonomy.pdf", plot_B2, width = 4, height = 4, dpi = 300)
ggsave("../output/Figure_2/Panel_A3_Euk_Diversity.pdf", plot_A3, width = 4, height = 4, dpi = 300)
ggsave("../output/Figure_2/Panel_B3_Pro_Diversity.pdf", plot_B3, width = 4, height = 4, dpi = 300)
ggsave("../output/Figure_2/Panel_A4_Euk_NMDS.pdf", plot_A4, width = 4, height = 4, dpi = 300)
ggsave("../output/Figure_2/Panel_B4_Pro_NMDS.pdf", plot_B4, width = 4, height = 4, dpi = 300)

# Save UpSet plots
cat("Saving UpSet plots...\n")

# Save Eukaryotic UpSet plot
pdf("../output/Figure_2/Panel_A1_Euk_UpSet.pdf", width = 6, height = 4)
print(Upset_euk)
dev.off()

# Save Prokaryotic UpSet plot
pdf("../output/Figure_2/Panel_B1_Pro_UpSet.pdf", width = 6, height = 4)
print(Upset_pro)
dev.off()

# Extract legends for taxonomy plots
legend_euk_tax <- get_legend(
  ggplot(euk.asv.prop.tax.simp.plot, 
         aes(x = Sample_type, y = proportion_ASV, fill = Taxonomic_group)) +
    geom_boxplot() +
    scale_fill_brewer(palette = "Dark2", name = "Eukaryotic groups") +
    theme_minimal() +
    theme(legend.position = "right") +
    guides(fill = guide_legend(override.aes = list(size = 3)))
)

legend_pro_tax <- get_legend(
  ggplot(pro.asv.prop.tax.simp.plot, 
         aes(x = Sample_type, y = proportion_ASV, fill = Taxonomic_group)) +
    geom_boxplot() +
    scale_fill_brewer(palette = "Set2", name = "Prokaryotic groups") +
    theme_minimal() +
    theme(legend.position = "right") +
    guides(fill = guide_legend(override.aes = list(size = 3)))
)

# Now the existing legend extractions for NMDS
legend_site_fill <- get_legend(
  ggplot(NMDS.scores.euks, aes(x = NMDS1, y = NMDS2, fill = Site)) +
    geom_point(size = 4, shape = 21, color = "black", stroke = 0.8) +
    scale_fill_viridis_d(name = "Site") +
    theme_minimal() +
    theme(legend.position = "right") +
    guides(fill = guide_legend(override.aes = list(size = 3)))
)

legend_shape_sample <- get_legend(
  ggplot(NMDS.scores.euks, aes(x = NMDS1, y = NMDS2, shape = Sample_type)) +
    geom_point(size = 4, fill = "grey50", color = "black", stroke = 0.8) +
    scale_shape_manual(
      name = "Sample type",
      values = c("Foraminifera" = 21, "Sediment" = 24, "Seawater" = 22)
    ) +
    theme_minimal() +
    theme(legend.position = "right") +
    guides(shape = guide_legend(override.aes = list(size = 3)))
)

legend_size_depth <- get_legend(
  ggplot(NMDS.scores.euks, aes(x = NMDS1, y = NMDS2, size = Depth_cat)) +
    geom_point(shape = 21, fill = "grey50", color = "black", stroke = 0.8) +
    scale_size_manual(
      name = "Depth",
      values = c("Deep" = 2, "Shallow" = 4)
    ) +
    theme_minimal() +
    theme(legend.position = "right")
)

# Now save all legends
ggsave("../output/Figure_2/Legend_Eukaryotic_Taxonomy.pdf", legend_euk_tax, width = 3, height = 2, dpi = 300)
ggsave("../output/Figure_2/Legend_Prokaryotic_Taxonomy.pdf", legend_pro_tax, width = 3, height = 2, dpi = 300)
ggsave("../output/Figure_2/Legend_Site_Fill.pdf", legend_site_fill, width = 2, height = 1.5, dpi = 300)
ggsave("../output/Figure_2/Legend_Sample_Type_Shape.pdf", legend_shape_sample, width = 2.5, height = 1.5, dpi = 300)
ggsave("../output/Figure_2/Legend_Depth_Size.pdf", legend_size_depth, width = 2, height = 1.5, dpi = 300)

##############################################
#    COMPREHENSIVE FORAMINIFERAL ANALYSIS    #
#              FIGURE 3                      #
##############################################

# Function to prepare foraminiferal data with specific filtering
prepare_foram_data_filtered <- function(asv_table, metadata_formatted, simplified_taxonomy, analysis_type) {
  foram_data <- asv_table %>% 
    t() %>% 
    as.data.frame() %>% 
    tibble::rownames_to_column(var = "Extraction_Voucher") %>%
    dplyr::inner_join(metadata_formatted, by = "Extraction_Voucher") %>%
    dplyr::filter(Sample_type == "single_cell")  # Keep original naming for filtering
  
  # Filter ASVs based on analysis type
  if (analysis_type == "diatoms") {
    target_asvs <- simplified_taxonomy %>% 
      dplyr::filter(Taxonomic_group == "Bacillariophyta") %>% 
      dplyr::pull(ASV_ID)
  } else if (analysis_type == "prokaryotes_no_chloroplast") {
    target_asvs <- simplified_taxonomy %>% 
      dplyr::filter(Taxonomic_group != "Chloroplast") %>% 
      dplyr::pull(ASV_ID)
  }
  
  # Select target columns plus metadata
  metadata_cols <- c("Extraction_Voucher", "Site", "Depth_cat", "Sample_type", "Substrate")
  target_cols <- intersect(target_asvs, names(foram_data))
  foram_data_filtered <- foram_data %>% dplyr::select(dplyr::all_of(c(metadata_cols, target_cols)))
  
  # Recalculate proportions after filtering to the target group
  # Extract community matrix (ASV columns only)
  community_cols <- setdiff(names(foram_data_filtered), metadata_cols)
  community_matrix <- foram_data_filtered %>% dplyr::select(dplyr::all_of(community_cols))
  
  # Recalculate proportions so each sample sums to 1 within the filtered group
  community_matrix_prop <- community_matrix %>%
    as.matrix() %>%
    prop.table(margin = 1) %>%  # Recalculate proportions by row (sample)
    as.data.frame()
  
  # Combine recalculated proportions with metadata
  foram_data_filtered <-dplyr::bind_cols(
    foram_data_filtered %>% dplyr::select(dplyr::all_of(metadata_cols)),
    community_matrix_prop
  )
  
  cat("  Filtered data:", nrow(foram_data_filtered), "samples,", length(target_cols), "ASVs\n")
  cat("  Proportions recalculated - samples now sum to 1 within", analysis_type, "\n")
  
  return(foram_data_filtered)
}

# Prepare filtered datasets
diatom_foram <- prepare_foram_data_filtered(euk.asv.merged, EUK_META_FORMATED, 
                                            TAX_EUK_SIMPLIFIED, "diatoms")
prokaryote_foram <- prepare_foram_data_filtered(pro.asv.merged, PRO_META_FORMATED, 
                                                TAX_PRO_SIMPLIFIED, "prokaryotes_no_chloroplast")

##############################################
#     MANUAL PAIRWISE PERMANOVA FUNCTION    #
##############################################

manual_pairwise_adonis <- function(community_matrix, grouping_factor, p_adjust_method = "fdr") {
  unique_groups <- unique(grouping_factor)
  n_groups <- length(unique_groups)
  
  if (n_groups < 2) return(NULL)
  
  pairwise_combinations <- combn(unique_groups, 2, simplify = FALSE)
  
  results <- data.frame(
    comparison = character(),
    F_statistic = numeric(),
    R2 = numeric(),
    p_value = numeric(),
    stringsAsFactors = FALSE
  )
  
  for (pair in pairwise_combinations) {
    subset_indices <- grouping_factor %in% pair
    subset_community <- community_matrix[subset_indices, ]
    subset_groups <- grouping_factor[subset_indices]
    
    pairwise_result <- adonis2(
      subset_community ~ subset_groups,
      permutations = 999,
      method = "bray"
    )
    
    comparison_name <- paste(pair[1], "vs", pair[2])
    results <- rbind(results, data.frame(
      comparison = comparison_name,
      F_statistic = pairwise_result$F[1],
      R2 = pairwise_result$R2[1],
      p_value = pairwise_result$`Pr(>F)`[1]
    ))
  }
  
  results$p_adjusted <- p.adjust(results$p_value, method = p_adjust_method)
  return(results)
}

##############################################
#    COMPREHENSIVE ANALYSIS FUNCTION        #
##############################################

perform_comprehensive_analysis <- function(foram_data, analysis_name) {
  cat(paste("Analyzing", analysis_name, "...\n"))
  
  # Separate community matrix from metadata
  metadata_cols <- c("Extraction_Voucher", "Site", "Depth_cat", "Sample_type", "Substrate")
  community_matrix <- foram_data %>% dplyr::select(-dplyr::all_of(metadata_cols))
  sample_metadata <- foram_data %>% dplyr::select(dplyr::all_of(metadata_cols))
  
  # Remove zero-sum rows/columns
  non_zero_rows <- rowSums(community_matrix) > 0
  community_matrix <- community_matrix[non_zero_rows, colSums(community_matrix) > 0]
  sample_metadata <- sample_metadata[non_zero_rows, ]
  
  # Set rownames for tracking
  rownames(community_matrix) <- sample_metadata$Extraction_Voucher
  rownames(sample_metadata) <- sample_metadata$Extraction_Voucher
  
  cat("  Final dataset:", nrow(community_matrix), "samples,", ncol(community_matrix), "ASVs\n")
  
  # =================
  # ALPHA DIVERSITY ANALYSIS
  # =================
  
  alpha_diversity <- diversity(community_matrix, index = "invsimpson") %>%
    as.data.frame() %>%
    setNames("InvSimpson") %>%
    cbind(sample_metadata %>% dplyr::select(-Extraction_Voucher))
  
  # Test ANOVA assumptions first
  anova_model <- aov(InvSimpson ~ Site * Depth_cat * Substrate, data = alpha_diversity)
  shapiro_test <- shapiro.test(residuals(anova_model))
  levene_test <- car::leveneTest(InvSimpson ~ Site * Depth_cat * Substrate, data = alpha_diversity)
  
  assumptions_met <- shapiro_test$p.value >= 0.05 && levene_test$`Pr(>F)`[1] >= 0.05
  
  if (assumptions_met) {
    # Use parametric ANOVA
    anova_results <- summary(anova_model)
    nonparam_tests <- NULL
    cat("  ANOVA assumptions met - using parametric tests\n")
  } else {
    # Use non-parametric alternatives
    cat("  ANOVA assumptions violated - using non-parametric tests\n")
    anova_results <- NULL
    
    # Kruskal-Wallis tests for main effects
    kruskal_site <- kruskal.test(InvSimpson ~ Site, data = alpha_diversity)
    kruskal_depth <- kruskal.test(InvSimpson ~ Depth_cat, data = alpha_diversity)
    kruskal_substrate <- kruskal.test(InvSimpson ~ Substrate, data = alpha_diversity)
    
    # Post-hoc pairwise comparisons if significant
    pairwise_site <- NULL
    pairwise_depth <- NULL
    pairwise_substrate <- NULL
    
    if (kruskal_site$p.value < 0.05) {
      pairwise_site <- pairwise.wilcox.test(alpha_diversity$InvSimpson, 
                                            alpha_diversity$Site, 
                                            p.adjust.method = "fdr")
    }
    if (kruskal_depth$p.value < 0.05) {
      pairwise_depth <- pairwise.wilcox.test(alpha_diversity$InvSimpson, 
                                             alpha_diversity$Depth_cat, 
                                             p.adjust.method = "fdr")
    }
    if (kruskal_substrate$p.value < 0.05) {
      pairwise_substrate <- pairwise.wilcox.test(alpha_diversity$InvSimpson, 
                                                 alpha_diversity$Substrate, 
                                                 p.adjust.method = "fdr")
    }
    
    nonparam_tests <- list(
      kruskal_site = kruskal_site,
      kruskal_depth = kruskal_depth,
      kruskal_substrate = kruskal_substrate,
      pairwise_site = pairwise_site,
      pairwise_depth = pairwise_depth,
      pairwise_substrate = pairwise_substrate
    )
  }
  
  # =================
  # BETA DIVERSITY ANALYSIS
  # =================
  
  # Calculate distance matrix
  bray_dist <- vegdist(community_matrix, method = "bray")
  
  # Test multivariate homogeneity of dispersions
  betadisp_site <- betadisper(bray_dist, sample_metadata$Site)
  betadisp_depth <- betadisper(bray_dist, sample_metadata$Depth_cat)
  betadisp_substrate <- betadisper(bray_dist, sample_metadata$Substrate)
  
  # Significance tests for betadispersion
  betadisp_test_site <- permutest(betadisp_site, permutations = 999)
  betadisp_test_depth <- permutest(betadisp_depth, permutations = 999)
  betadisp_test_substrate <- permutest(betadisp_substrate, permutations = 999)
  
  # Check if dispersions are homogeneous
  dispersions_homogeneous <- betadisp_test_site$tab$`Pr(>F)`[1] >= 0.05
  
  # PERMANOVA with full factorial design
  permanova_full <- adonis2(
    community_matrix ~ Site * Depth_cat * Substrate, 
    data = sample_metadata,
    permutations = 999,
    method = "bray",
    by = "terms"
  )
  
  # NMDS ordination (k=3 for robustness, will plot first 2 axes)
  cat("  Running NMDS (k=3)...\n")
  nmds_result <- metaMDS(community_matrix, distance = "bray", k = 3, try = 100, trace = FALSE)
  
  # Extract scores with metadata
  nmds_scores <- as.data.frame(scores(nmds_result)$sites)
  
  # Verify row order matches
  if (!all(rownames(nmds_scores) == rownames(sample_metadata))) {
    stop("ERROR: NMDS score row order doesn't match metadata!")
  }
  
  # Add metadata
  nmds_scores$Extraction_Voucher <- rownames(nmds_scores)
  nmds_scores$Site <- sample_metadata$Site
  nmds_scores$Depth_cat <- sample_metadata$Depth_cat
  nmds_scores$Substrate <- sample_metadata$Substrate
  
  # Pairwise comparisons if Site effect significant
  pairwise_site_permanova <- NULL
  if (permanova_full$`Pr(>F)`[1] < 0.05) {
    cat("  Running pairwise PERMANOVA for Site...\n")
    pairwise_site_permanova <- manual_pairwise_adonis(community_matrix, sample_metadata$Site)
  }
  
  cat("  ✓", analysis_name, "complete\n\n")
  
  # Return comprehensive results
  return(list(
    # Alpha diversity
    alpha_diversity = alpha_diversity,
    assumptions_met = assumptions_met,
    anova_results = anova_results,
    anova_model = anova_model,
    shapiro_test = shapiro_test,
    levene_test = levene_test,
    nonparam_tests = nonparam_tests,
    
    # Beta diversity  
    permanova = permanova_full,
    dispersions_homogeneous = dispersions_homogeneous,
    betadisp_site = betadisp_test_site,
    betadisp_depth = betadisp_test_depth,
    betadisp_substrate = betadisp_test_substrate,
    pairwise_site = pairwise_site_permanova,
    
    # Ordination
    nmds = nmds_result,
    nmds_scores = nmds_scores,
    
    # Data
    community_matrix = community_matrix,
    metadata = sample_metadata,
    n_samples = nrow(community_matrix),
    n_taxa = ncol(community_matrix)
  ))
}

##############################################
#        RUN COMPREHENSIVE ANALYSES         #
##############################################

# Run analyses
diatom_analysis <- perform_comprehensive_analysis(diatom_foram, "Diatom symbionts")
prokaryote_analysis <- perform_comprehensive_analysis(prokaryote_foram, "Prokaryotes (no chloroplast)")

##############################################
#           RESULTS SUMMARY                 #
##############################################

cat("=== COMPREHENSIVE STATISTICAL RESULTS ===\n\n")

# Alpha diversity results
cat("ALPHA DIVERSITY RESULTS:\n")
cat("\nDIATOM SYMBIONTS:\n")
if (diatom_analysis$assumptions_met) {
  print(diatom_analysis$anova_results)
} else {
  cat("Non-parametric tests used due to assumption violations:\n")
  cat("Site effect: χ² =", round(diatom_analysis$nonparam_tests$kruskal_site$statistic, 3),
      ", p =", round(diatom_analysis$nonparam_tests$kruskal_site$p.value, 4), "\n")
  cat("Depth effect: χ² =", round(diatom_analysis$nonparam_tests$kruskal_depth$statistic, 3),
      ", p =", round(diatom_analysis$nonparam_tests$kruskal_depth$p.value, 4), "\n")
  cat("Substrate effect: χ² =", round(diatom_analysis$nonparam_tests$kruskal_substrate$statistic, 3),
      ", p =", round(diatom_analysis$nonparam_tests$kruskal_substrate$p.value, 4), "\n")
}

cat("\nPROKARYOTES:\n")
if (prokaryote_analysis$assumptions_met) {
  print(prokaryote_analysis$anova_results)
} else {
  cat("Non-parametric tests used due to assumption violations:\n")
  cat("Site effect: χ² =", round(prokaryote_analysis$nonparam_tests$kruskal_site$statistic, 3),
      ", p =", round(prokaryote_analysis$nonparam_tests$kruskal_site$p.value, 4), "\n")
  cat("Depth effect: χ² =", round(prokaryote_analysis$nonparam_tests$kruskal_depth$statistic, 3),
      ", p =", round(prokaryote_analysis$nonparam_tests$kruskal_depth$p.value, 4), "\n")
  cat("Substrate effect: χ² =", round(prokaryote_analysis$nonparam_tests$kruskal_substrate$statistic, 3),
      ", p =", round(prokaryote_analysis$nonparam_tests$kruskal_substrate$p.value, 4), "\n")
}

# Beta diversity results
cat("\nBETA DIVERSITY PERMANOVA RESULTS:\n\n")
cat("DIATOM SYMBIONTS (n =", diatom_analysis$n_samples, "samples,", diatom_analysis$n_taxa, "taxa):\n")
if (diatom_analysis$dispersions_homogeneous) {
  cat("Dispersions homogeneous - standard PERMANOVA interpretation applies\n")
} else {
  cat("WARNING: Dispersions heterogeneous - results reflect both compositional and variance differences\n")
}
print(diatom_analysis$permanova)

cat("\nPROKARYOTES (n =", prokaryote_analysis$n_samples, "samples,", prokaryote_analysis$n_taxa, "taxa):\n")
if (prokaryote_analysis$dispersions_homogeneous) {
  cat("Dispersions homogeneous - standard PERMANOVA interpretation applies\n")
} else {
  cat("WARNING: Dispersions heterogeneous - results reflect both compositional and variance differences\n")
}
print(prokaryote_analysis$permanova)

# NMDS stress values
cat("\nNMDS STRESS VALUES (k=3, plotting first 2 axes):\n")
cat("Diatoms:", round(diatom_analysis$nmds$stress, 3), "\n")
cat("Prokaryotes:", round(prokaryote_analysis$nmds$stress, 3), "\n\n")

# Prepare plotting data
diatom_nmds <- diatom_analysis$nmds
prokaryote_nmds <- prokaryote_analysis$nmds
diatom_nmds_scores <- diatom_analysis$nmds_scores %>% dplyr::select(NMDS1, NMDS2, Site, Depth_cat, Substrate)
prokaryote_nmds_scores <- prokaryote_analysis$nmds_scores %>% dplyr::select(NMDS1, NMDS2, Site, Depth_cat, Substrate)
diatom_diversity <- diatom_analysis$alpha_diversity
prokaryote_diversity <- prokaryote_analysis$alpha_diversity


##############################################
#     EXPORT STATISTICAL RESULTS AS SI      #
##############################################

cat("Exporting statistical results to supplementary tables...\n")

# ========================================
# TABLE S1 & S2: ALPHA DIVERSITY TESTS
# ========================================

# Function to extract pairwise results in tidy format
extract_pairwise <- function(pairwise_test, test_name) {
  if (is.null(pairwise_test)) return(NULL)
  
  pairwise_matrix <- pairwise_test$p.value
  n_groups <- nrow(pairwise_matrix)
  group_names <- rownames(pairwise_matrix)
  
  results <- data.frame()
  for (i in 2:n_groups) {
    for (j in 1:(i-1)) {
      results <- rbind(results, data.frame(
        Factor = test_name,
        Comparison = paste(group_names[i], "vs", group_names[j]),
        p_value = pairwise_matrix[i, j]
      ))
    }
  }
  return(results)
}

# Build alpha diversity table
alpha_div_results <- data.frame(
  Dataset = character(),
  Factor = character(),
  Test = character(),
  Statistic = character(),
  df = numeric(),
  p_value = numeric(),
  stringsAsFactors = FALSE
)

# Diatoms
alpha_div_results <- rbind(alpha_div_results, data.frame(
  Dataset = "Diatoms",
  Factor = "Site",
  Test = "Kruskal-Wallis",
  Statistic = paste0("χ² = ", round(diatom_analysis$nonparam_tests$kruskal_site$statistic, 3)),
  df = diatom_analysis$nonparam_tests$kruskal_site$parameter,
  p_value = round(diatom_analysis$nonparam_tests$kruskal_site$p.value, 4)
))

alpha_div_results <- rbind(alpha_div_results, data.frame(
  Dataset = "Diatoms",
  Factor = "Depth",
  Test = "Kruskal-Wallis",
  Statistic = paste0("χ² = ", round(diatom_analysis$nonparam_tests$kruskal_depth$statistic, 3)),
  df = diatom_analysis$nonparam_tests$kruskal_depth$parameter,
  p_value = round(diatom_analysis$nonparam_tests$kruskal_depth$p.value, 4)
))

alpha_div_results <- rbind(alpha_div_results, data.frame(
  Dataset = "Diatoms",
  Factor = "Substrate",
  Test = "Kruskal-Wallis",
  Statistic = paste0("χ² = ", round(diatom_analysis$nonparam_tests$kruskal_substrate$statistic, 3)),
  df = diatom_analysis$nonparam_tests$kruskal_substrate$parameter,
  p_value = round(diatom_analysis$nonparam_tests$kruskal_substrate$p.value, 4)
))

# Prokaryotes
alpha_div_results <- rbind(alpha_div_results, data.frame(
  Dataset = "Prokaryotes",
  Factor = "Site",
  Test = "Kruskal-Wallis",
  Statistic = paste0("χ² = ", round(prokaryote_analysis$nonparam_tests$kruskal_site$statistic, 3)),
  df = prokaryote_analysis$nonparam_tests$kruskal_site$parameter,
  p_value = round(prokaryote_analysis$nonparam_tests$kruskal_site$p.value, 4)
))

alpha_div_results <- rbind(alpha_div_results, data.frame(
  Dataset = "Prokaryotes",
  Factor = "Depth",
  Test = "Kruskal-Wallis",
  Statistic = paste0("χ² = ", round(prokaryote_analysis$nonparam_tests$kruskal_depth$statistic, 3)),
  df = prokaryote_analysis$nonparam_tests$kruskal_depth$parameter,
  p_value = round(prokaryote_analysis$nonparam_tests$kruskal_depth$p.value, 4)
))

alpha_div_results <- rbind(alpha_div_results, data.frame(
  Dataset = "Prokaryotes",
  Factor = "Substrate",
  Test = "Kruskal-Wallis",
  Statistic = paste0("χ² = ", round(prokaryote_analysis$nonparam_tests$kruskal_substrate$statistic, 3)),
  df = prokaryote_analysis$nonparam_tests$kruskal_substrate$parameter,
  p_value = round(prokaryote_analysis$nonparam_tests$kruskal_substrate$p.value, 4)
))

write.table(alpha_div_results, 
            "../output/Supplementary_Tables/Table_S1_Alpha_Diversity_Tests.tsv",
            sep = "\t", row.names = FALSE, quote = FALSE)

# Function to extract pairwise results in tidy format
extract_pairwise <- function(pairwise_test, test_name) {
  if (is.null(pairwise_test)) return(NULL)
  
  pairwise_matrix <- pairwise_test$p.value
  n_groups <- nrow(pairwise_matrix)
  group_names <- rownames(pairwise_matrix)
  
  # Handle case where there are only 2 groups (1x1 matrix)
  if (n_groups == 1) {
    return(data.frame(
      Factor = test_name,
      Comparison = paste(group_names[1], "vs", colnames(pairwise_matrix)[1]),
      p_value = pairwise_matrix[1, 1]
    ))
  }
  
  # Handle case with 3+ groups
  results <- data.frame()
  for (i in 2:n_groups) {
    for (j in 1:(i-1)) {
      results <- rbind(results, data.frame(
        Factor = test_name,
        Comparison = paste(group_names[i], "vs", group_names[j]),
        p_value = pairwise_matrix[i, j]
      ))
    }
  }
  return(results)
}

# Now extract pairwise comparisons
pairwise_diatom_site <- extract_pairwise(diatom_analysis$nonparam_tests$pairwise_site, "Site")
pairwise_diatom_depth <- extract_pairwise(diatom_analysis$nonparam_tests$pairwise_depth, "Depth")
pairwise_diatom_substrate <- extract_pairwise(diatom_analysis$nonparam_tests$pairwise_substrate, "Substrate")

pairwise_prokaryote_site <- extract_pairwise(prokaryote_analysis$nonparam_tests$pairwise_site, "Site")
pairwise_prokaryote_depth <- extract_pairwise(prokaryote_analysis$nonparam_tests$pairwise_depth, "Depth")
pairwise_prokaryote_substrate <- extract_pairwise(prokaryote_analysis$nonparam_tests$pairwise_substrate, "Substrate")

# Combine all pairwise results
pairwise_all <- rbind(
  if (!is.null(pairwise_diatom_site)) cbind(Dataset = "Diatoms", pairwise_diatom_site),
  if (!is.null(pairwise_diatom_depth)) cbind(Dataset = "Diatoms", pairwise_diatom_depth),
  if (!is.null(pairwise_diatom_substrate)) cbind(Dataset = "Diatoms", pairwise_diatom_substrate),
  if (!is.null(pairwise_prokaryote_site)) cbind(Dataset = "Prokaryotes", pairwise_prokaryote_site),
  if (!is.null(pairwise_prokaryote_depth)) cbind(Dataset = "Prokaryotes", pairwise_prokaryote_depth),
  if (!is.null(pairwise_prokaryote_substrate)) cbind(Dataset = "Prokaryotes", pairwise_prokaryote_substrate)
)

# Extract pairwise comparisons
pairwise_diatom_site <- extract_pairwise(diatom_analysis$nonparam_tests$pairwise_site, "Site")
pairwise_diatom_depth <- extract_pairwise(diatom_analysis$nonparam_tests$pairwise_depth, "Depth")
pairwise_diatom_substrate <- extract_pairwise(diatom_analysis$nonparam_tests$pairwise_substrate, "Substrate")

pairwise_prokaryote_site <- extract_pairwise(prokaryote_analysis$nonparam_tests$pairwise_site, "Site")
pairwise_prokaryote_depth <- extract_pairwise(prokaryote_analysis$nonparam_tests$pairwise_depth, "Depth")
pairwise_prokaryote_substrate <- extract_pairwise(prokaryote_analysis$nonparam_tests$pairwise_substrate, "Substrate")

# Combine all pairwise results
pairwise_all <- rbind(
  if (!is.null(pairwise_diatom_site)) cbind(Dataset = "Diatoms", pairwise_diatom_site),
  if (!is.null(pairwise_diatom_depth)) cbind(Dataset = "Diatoms", pairwise_diatom_depth),
  if (!is.null(pairwise_diatom_substrate)) cbind(Dataset = "Diatoms", pairwise_diatom_substrate),
  if (!is.null(pairwise_prokaryote_site)) cbind(Dataset = "Prokaryotes", pairwise_prokaryote_site),
  if (!is.null(pairwise_prokaryote_depth)) cbind(Dataset = "Prokaryotes", pairwise_prokaryote_depth),
  if (!is.null(pairwise_prokaryote_substrate)) cbind(Dataset = "Prokaryotes", pairwise_prokaryote_substrate)
)

if (!is.null(pairwise_all) && nrow(pairwise_all) > 0) {
  pairwise_all$p_value <- round(pairwise_all$p_value, 4)
  write.table(pairwise_all, 
              "../output/Supplementary_Tables/Table_S2_Pairwise_Wilcoxon.tsv",
              sep = "\t", row.names = FALSE, quote = FALSE)
}

# ========================================
# TABLE S3: PERMANOVA RESULTS
# ========================================

# Function to extract PERMANOVA results
extract_permanova <- function(permanova_result, dataset_name) {
  perm_df <- as.data.frame(permanova_result)
  perm_df$Term <- rownames(perm_df)
  perm_df$Dataset <- dataset_name
  
  # Reorder columns
  perm_df <- perm_df %>% 
    dplyr::select(Dataset, Term, Df, SumOfSqs, R2, F, `Pr(>F)`) %>%
    dplyr::rename(
      df = Df,
      SS = SumOfSqs,
      F_statistic = F,
      p_value = `Pr(>F)`
    )
  
  # Round numeric columns
  perm_df$SS <- round(perm_df$SS, 4)
  perm_df$R2 <- round(perm_df$R2, 4)
  perm_df$F_statistic <- round(perm_df$F_statistic, 3)
  perm_df$p_value <- round(perm_df$p_value, 4)
  
  return(perm_df)
}

permanova_diatom <- extract_permanova(diatom_analysis$permanova, "Diatoms")
permanova_prokaryote <- extract_permanova(prokaryote_analysis$permanova, "Prokaryotes")

permanova_combined <- rbind(permanova_diatom, permanova_prokaryote)

write.table(permanova_combined, 
            "../output/Supplementary_Tables/Table_S3_PERMANOVA_Results.tsv",
            sep = "\t", row.names = FALSE, quote = FALSE)

# ========================================
# TABLE S4: PAIRWISE PERMANOVA
# ========================================

# Combine pairwise PERMANOVA results
pairwise_permanova_diatom <- diatom_analysis$pairwise_site
pairwise_permanova_prokaryote <- prokaryote_analysis$pairwise_site

if (!is.null(pairwise_permanova_diatom)) {
  pairwise_permanova_diatom$Dataset <- "Diatoms"
  pairwise_permanova_diatom <- pairwise_permanova_diatom %>% 
    dplyr::select(Dataset, comparison, F_statistic, R2, p_value, p_adjusted)
}

if (!is.null(pairwise_permanova_prokaryote)) {
  pairwise_permanova_prokaryote$Dataset <- "Prokaryotes"
  pairwise_permanova_prokaryote <- pairwise_permanova_prokaryote %>% 
    dplyr::select(Dataset, comparison, F_statistic, R2, p_value, p_adjusted)
}

pairwise_permanova_combined <- rbind(pairwise_permanova_diatom, pairwise_permanova_prokaryote)

# Round numeric columns
pairwise_permanova_combined$F_statistic <- round(pairwise_permanova_combined$F_statistic, 3)
pairwise_permanova_combined$R2 <- round(pairwise_permanova_combined$R2, 4)
pairwise_permanova_combined$p_value <- round(pairwise_permanova_combined$p_value, 4)
pairwise_permanova_combined$p_adjusted <- round(pairwise_permanova_combined$p_adjusted, 4)

write.table(pairwise_permanova_combined, 
            "../output/Supplementary_Tables/Table_S4_Pairwise_PERMANOVA.tsv",
            sep = "\t", row.names = FALSE, quote = FALSE)

# ========================================
# TABLE S5: BETADISPERSION TESTS
# ========================================

# Function to extract betadispersion results
extract_betadisp <- function(betadisp_test, factor_name, dataset_name) {
  data.frame(
    Dataset = dataset_name,
    Factor = factor_name,
    F_statistic = round(betadisp_test$tab$F[1], 3),
    df1 = betadisp_test$tab$Df[1],
    df2 = betadisp_test$tab$Df[2],
    p_value = round(betadisp_test$tab$`Pr(>F)`[1], 4)
  )
}

betadisp_results <- rbind(
  extract_betadisp(diatom_analysis$betadisp_site, "Site", "Diatoms"),
  extract_betadisp(diatom_analysis$betadisp_depth, "Depth", "Diatoms"),
  extract_betadisp(diatom_analysis$betadisp_substrate, "Substrate", "Diatoms"),
  extract_betadisp(prokaryote_analysis$betadisp_site, "Site", "Prokaryotes"),
  extract_betadisp(prokaryote_analysis$betadisp_depth, "Depth", "Prokaryotes"),
  extract_betadisp(prokaryote_analysis$betadisp_substrate, "Substrate", "Prokaryotes")
)

write.table(betadisp_results, 
            "../output/Supplementary_Tables/Table_S5_Betadispersion_Tests.tsv",
            sep = "\t", row.names = FALSE, quote = FALSE)

# ========================================
# TABLE S6: MANTEL TEST
# ========================================

cat("Running Mantel test...\n")

# Calculate dissimilarity matrices for both datasets
diatom_bray <- vegdist(diatom_analysis$community_matrix, method = "bray")
prokaryote_bray <- vegdist(prokaryote_analysis$community_matrix, method = "bray")

# Ensure same samples in both matrices
common_samples <- intersect(
  labels(diatom_bray),
  labels(prokaryote_bray)
)

# Subset to common samples
diatom_bray_subset <- as.dist(as.matrix(diatom_bray)[common_samples, common_samples])
prokaryote_bray_subset <- as.dist(as.matrix(prokaryote_bray)[common_samples, common_samples])

# Perform Mantel test
mantel_result <- mantel(diatom_bray_subset, prokaryote_bray_subset, 
                        method = "spearman", permutations = 999)

mantel_table <- data.frame(
  Test = "Mantel test",
  Comparison = "Diatom vs Prokaryote dissimilarity",
  Method = "Spearman correlation",
  n_samples = length(common_samples),
  Mantel_r = round(mantel_result$statistic, 3),
  p_value = round(mantel_result$signif, 4),
  Permutations = 999
)

write.table(mantel_table, 
            "../output/Supplementary_Tables/Table_S6_Mantel_Test.tsv",
            sep = "\t", row.names = FALSE, quote = FALSE)

##############################################
#        FIGURE 3 PANEL GENERATION          #
##############################################

cat("Creating Figure 3 panels...\n")

# Clean theme for all panels
create_clean_theme <- function() {
  theme_minimal() +
    theme(
      panel.border = element_rect(color = "black", fill = NA, linewidth = 0.8),
      strip.background = element_rect(fill = "grey90", color = "black"),
      strip.text = element_text(size = 8, face = "bold"),
      legend.position = "none",
      axis.text = element_text(size = 8),
      axis.title = element_text(size = 9),
      plot.title = element_text(size = 10, hjust = 0.5, face = "bold"),
      aspect.ratio = 1
    )
}

# Panel A: Diatom alpha diversity
panel_A <- ggplot(diatom_diversity, aes(x = Depth_cat, y = InvSimpson)) +
  geom_boxplot(aes(fill = Substrate), alpha = 0.7, outlier.shape = NA) +
  geom_jitter(aes(fill = Substrate), 
              shape = 21, size = 2, stroke = 0.8, color = "black",
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.2)) +
  facet_wrap(~ Site, scales = "free_x") +
  scale_fill_manual(values = c("lightblue", "lightcoral"), 
                    name = "Substrate",
                    labels = c("Algae", "Pebbles")) +
  labs(title = "A: Diatom alpha diversity", 
       y = "Inverse Simpson index",
       x = "Depth category") +
  create_clean_theme()

# Panel B: Prokaryote alpha diversity  
panel_B <- ggplot(prokaryote_diversity, aes(x = Depth_cat, y = InvSimpson)) +
  geom_boxplot(aes(fill = Substrate), alpha = 0.7, outlier.shape = NA) +
  geom_jitter(aes(fill = Substrate), 
              shape = 21, size = 2, stroke = 0.8, color = "black",
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.2)) +
  facet_wrap(~ Site, scales = "free_x") +
  scale_fill_manual(values = c("lightblue", "lightcoral"), 
                    name = "Substrate",
                    labels = c("Algae", "Pebbles")) +
  labs(title = "B: Prokaryote alpha diversity", 
       y = "Inverse Simpson index",
       x = "Depth category") +
  create_clean_theme()

# Panel C: Diatom NMDS
panel_C <- ggplot(diatom_nmds_scores, aes(x = NMDS1, y = NMDS2)) +
  geom_point(aes(fill = Site, shape = Substrate, size = Depth_cat), 
             color = "black", stroke = 0.8) +
  scale_fill_viridis_d(name = "Site") +
  scale_shape_manual(values = c(21, 24), name = "Substrate", labels = c("Algae", "Pebbles")) +
  scale_size_manual(values = c("Deep" = 2, "Shallow" = 4), name = "Depth") +
  labs(title = "C: Diatom beta diversity",
       subtitle = paste("Stress =", round(diatom_nmds$stress, 3))) +
  create_clean_theme()

# Panel D: Prokaryote NMDS
panel_D <- ggplot(prokaryote_nmds_scores, aes(x = NMDS1, y = NMDS2)) +
  geom_point(aes(fill = Site, shape = Substrate, size = Depth_cat), 
             color = "black", stroke = 0.8) +
  scale_fill_viridis_d(name = "Site") +
  scale_shape_manual(values = c(21, 24), name = "Substrate", labels = c("Algae", "Pebbles")) +
  scale_size_manual(values = c("Deep" = 2, "Shallow" = 4), name = "Depth") +
  labs(title = "D: Prokaryote beta diversity",
       subtitle = paste("Stress =", round(prokaryote_nmds$stress, 3))) +
  create_clean_theme()

##############################################
#     SAVE INDIVIDUAL PANELS WITH LEGENDS   #
##############################################
# Panel A with legend
panel_A_with_legend <- panel_A + 
  theme(legend.position = "bottom", legend.direction = "horizontal") +
  guides(fill = guide_legend(title = "Substrate", override.aes = list(shape = 21, size = 3)))

ggsave("../output/Figure_3/Panel_A_Diatom_Alpha_WithLegend.pdf", panel_A_with_legend, 
       width = 6, height = 5, dpi = 300)

# Panel B with legend  
panel_B_with_legend <- panel_B + 
  theme(legend.position = "bottom", legend.direction = "horizontal") +
  guides(fill = guide_legend(title = "Substrate", override.aes = list(shape = 21, size = 3)))

ggsave("../output/Figure_3/Panel_B_Prokaryote_Alpha_WithLegend.pdf", panel_B_with_legend, 
       width = 6, height = 5, dpi = 300)

# Panel C with all legends
panel_C_with_legend <- panel_C + 
  theme(legend.position = "bottom", legend.direction = "horizontal", legend.box = "vertical") +
  guides(
    fill = guide_legend(title = "Site", override.aes = list(shape = 21, size = 3), order = 1),
    shape = guide_legend(title = "Substrate", override.aes = list(fill = "grey50", size = 3), order = 2),
    size = guide_legend(title = "Depth", override.aes = list(fill = "grey50", shape = 21), order = 3)
  )

ggsave("../output/Figure_3/Panel_C_Diatom_NMDS_WithLegend.pdf", panel_C_with_legend, 
       width = 6, height = 6, dpi = 300)

# Panel D with all legends
panel_D_with_legend <- panel_D + 
  theme(legend.position = "bottom", legend.direction = "horizontal", legend.box = "vertical") +
  guides(
    fill = guide_legend(title = "Site", override.aes = list(shape = 21, size = 3), order = 1),
    shape = guide_legend(title = "Substrate", override.aes = list(fill = "grey50", size = 3), order = 2),
    size = guide_legend(title = "Depth", override.aes = list(fill = "grey50", shape = 21), order = 3)
  )

ggsave("../output/Figure_3/Panel_D_Prokaryote_NMDS_WithLegend.pdf", panel_D_with_legend, 
       width = 6, height = 6, dpi = 300)

##############################################
#              FIGURE 4                     #
#     DIATOM DISTRIBUTION UPSET PLOT        #
##############################################

# Creating Figure 4: Diatom distribution across sample categories...\n\n")

##############################################
# STEP 1: PREPARE DIATOM DATA
##############################################

# Get diatom ASVs
diatom_asvs <- TAX_EUK_SIMPLIFIED %>%
  dplyr::filter(Taxonomic_group == "Bacillariophyta") %>%
  dplyr::pull(ASV_ID)

# Keep only diatoms present in merged community
diatom_asvs_present <- intersect(diatom_asvs, rownames(euk.asv.merged))

cat("Diatom ASVs to analyze:", length(diatom_asvs_present), "\n")

# Create diatom community matrix with metadata
diatom_community <- euk.asv.merged[diatom_asvs_present, ] %>%
  t() %>%
  as.data.frame() %>%
  tibble::rownames_to_column("Extraction_Voucher") %>%
  dplyr::left_join(EUK_META_FORMATED %>% 
                     dplyr::select(Extraction_Voucher, Sample_type, Site), 
                   by = "Extraction_Voucher")

##############################################
# STEP 2: CREATE 5 CATEGORIES
##############################################

# Create the categorical grouping
diatom_community_categorized <- diatom_community %>%
  dplyr::mutate(Category = case_when(
    Sample_type %in% c("sediment", "filter") ~ "Environmental",
    Sample_type == "single_cell" & Site == "Eilat" ~ "Foraminifera_Eilat",
    Sample_type == "single_cell" & Site == "Tel Shikmona" ~ "Foraminifera_Tel_Shikmona",
    Sample_type == "single_cell" & Site == "Plemmirio" ~ "Foraminifera_Plemmirio",
    Sample_type == "single_cell" & Site == "Capo Passero" ~ "Foraminifera_Capo_Passero",
    TRUE ~ "Other"
  )) %>%
  dplyr::filter(Category != "Other")  # Remove any uncategorized samples

# Check category distribution
cat("\nSample distribution across categories:\n")
print(table(diatom_community_categorized$Category))
cat("\n")

##############################################
# STEP 3: PREPARE UPSET DATA
##############################################

# Get ASV columns only
asv_columns <- diatom_asvs_present

# Create presence/absence matrix for each category
upset_data_list <- list()

for (category in unique(diatom_community_categorized$Category)) {
  # Get samples from this category
  category_samples <- diatom_community_categorized %>%
    dplyr::filter(Category == category)
  
  # Get ASVs present in this category (presence = at least one sample has it)
  category_asvs <- category_samples %>%
    dplyr::select(dplyr::all_of(asv_columns)) %>%
    summarise(across(everything(), ~sum(. > 0))) %>%
    tidyr::pivot_longer(everything(), names_to = "ASV_ID", values_to = "n_samples") %>%
    dplyr::filter(n_samples > 0) %>%
    dplyr::pull(ASV_ID)
  
  upset_data_list[[category]] <- category_asvs
  
  cat("Category:", category, "- ASVs present:", length(category_asvs), "\n")
}

cat("\n")

# Convert to UpSet format (ASVs as rows, categories as columns with 0/1)
all_asvs <- unique(unlist(upset_data_list))

upset_matrix <- data.frame(ASV_ID = all_asvs)

for (category in names(upset_data_list)) {
  upset_matrix[[category]] <- as.integer(upset_matrix$ASV_ID %in% upset_data_list[[category]])
}

# Convert to proper format for upset()
upset_matrix_final <- upset_matrix %>%
  tibble::column_to_rownames("ASV_ID")

cat("UpSet matrix dimensions:", nrow(upset_matrix_final), "ASVs ×", 
    ncol(upset_matrix_final), "categories\n\n")

##############################################
# STEP 4: CREATE UPSET PLOT
##############################################

cat("Creating UpSet plot...\n")

# Create UpSet plot with custom settings
diatom_upset_plot <- upset(
  upset_matrix_final,
  sets = c("Environmental", "Foraminifera_Eilat", "Foraminifera_Tel_Shikmona", 
           "Foraminifera_Plemmirio", "Foraminifera_Capo_Passero"),
  keep.order = TRUE,  # Keep the order as specified
  sets.bar.color = c("#33A02C", "#E31A1C", "#E31A1C", "#E31A1C", "#E31A1C"),  # Green for env, red for foram
  number.angles = 30,
  point.size = 4,
  line.size = 1.5,
  mainbar.y.label = "Number of Diatom ASVs",
  sets.x.label = "ASVs per Category",
  text.scale = c(1.5, 1.5, 1.3, 1.3, 2, 1.5),
  order.by = "freq",
  nintersects = 20  # Show top 20 intersections
)

##############################################
# STEP 5: SAVE UPSET PLOT
##############################################
# Save as PDF
pdf("../output/Figure_4/Figure_4_Diatom_Distribution_UpSet.pdf", 
    width = 10, height = 6)
print(diatom_upset_plot)
dev.off()


##############################################
#         FIGURE 4 - PART 2                 #
#   DIATOM ASSOCIATION CATEGORIES           #
#   (Relative Proportions by Locality)      #
##############################################

#Creating diatom association categories and plotting proportions.

##############################################
# STEP 1: CLASSIFY DIATOM ASVs INTO CATEGORIES
##############################################

cat("Classifying diatom ASVs into association categories...\n")

# Use the upset matrix from previous analysis
diatom_categories <- upset_matrix_final %>%
  tibble::rownames_to_column("ASV_ID") %>%
  dplyr::mutate(Association = case_when(
    # Shared across all 4 foram localities
    Foraminifera_Eilat == 1 & 
      Foraminifera_Tel_Shikmona == 1 & 
      Foraminifera_Plemmirio == 1 & 
      Foraminifera_Capo_Passero == 1 ~ "Shared_diatoms",
    
    # Mediterranean only (Tel Shikmona + Plemmirio + Capo Passero, NOT Eilat)
    Foraminifera_Eilat == 0 & 
      Foraminifera_Tel_Shikmona == 1 & 
      Foraminifera_Plemmirio == 1 & 
      Foraminifera_Capo_Passero == 1 ~ "Mediterranean_only",
    
    # Sicily only (Plemmirio + Capo Passero, NOT Eilat or Tel Shikmona)
    Foraminifera_Eilat == 0 & 
      Foraminifera_Tel_Shikmona == 0 & 
      Foraminifera_Plemmirio == 1 & 
      Foraminifera_Capo_Passero == 1 ~ "Sicily_only",
    
    # Environmental associated (present in Environmental AND at least one foram locality)
    Environmental == 1 & 
      (Foraminifera_Eilat == 1 | Foraminifera_Tel_Shikmona == 1 | 
         Foraminifera_Plemmirio == 1 | Foraminifera_Capo_Passero == 1) ~ "Environmental_associated",
    
    # All other combinations
    TRUE ~ "Other_associations"
  ))

# Summary of categories
cat("\n=== DIATOM ASSOCIATION CATEGORIES ===\n")
category_summary <- diatom_categories %>%
  dplyr::group_by(Association) %>%
  dplyr::summarize(n_ASVs = n(), .groups = "drop") %>%
  dplyr::arrange(desc(n_ASVs))

print(category_summary)

##############################################
# STEP 2: CALCULATE ABUNDANCE PER CATEGORY PER LOCALITY
##############################################

# Calculating relative abundance of each category at each locality.

# Get the community data with categories
diatom_with_categories <- diatom_community_categorized %>%
  dplyr::filter(Sample_type == "single_cell") %>%  # Focus on foraminifera only
  dplyr::select(Extraction_Voucher, Category, Site, dplyr::all_of(diatom_asvs_present))

# Calculate total abundance per category per sample
abundance_by_category <- data.frame()

for (site in c("Eilat", "Tel Shikmona", "Plemmirio", "Capo Passero")) {
  
  # Get samples from this site
  site_samples <- diatom_with_categories %>%
    dplyr::filter(Site == site)
  
  cat("  Processing", site, "-", nrow(site_samples), "samples\n")
  
  # For each sample, calculate abundance of each association category
  for (i in 1:nrow(site_samples)) {
    sample_data <- site_samples[i, ]
    sample_id <- sample_data$Extraction_Voucher
    
    # Get ASV abundances for this sample
    asv_abundances <- sample_data %>%
      dplyr::select(dplyr::all_of(diatom_asvs_present)) %>%
      tidyr::pivot_longer(everything(), names_to = "ASV_ID", values_to = "abundance")
    
    # Join with categories
    asv_with_cat <- asv_abundances %>%
      dplyr::left_join(diatom_categories %>% dplyr::select(ASV_ID, Association), by = "ASV_ID")
    
    # Sum abundance per category
    category_abundance <- asv_with_cat %>%
      dplyr::group_by(Association) %>%
      dplyr::summarize(total_abundance = sum(abundance), .groups = "drop")
    
    # Calculate proportions
    total_diatom_abundance <- sum(category_abundance$total_abundance)
    
    category_abundance <- category_abundance %>%
      dplyr::mutate(
        proportion = total_abundance / total_diatom_abundance,
        percentage = proportion * 100,
        Sample_ID = sample_id,
        Site = site
      )
    
    abundance_by_category <- rbind(abundance_by_category, category_abundance)
  }
}

cat("\n")

##############################################
# STEP 3: VISUALIZE PROPORTIONS
##############################################

cat("Creating visualizations...\n")

# Set factor levels for consistent ordering
abundance_by_category$Association <- factor(
  abundance_by_category$Association,
  levels = c("Shared_diatoms", "Mediterranean_only", "Sicily_only", 
             "Environmental_associated", "Other_associations")
)

abundance_by_category$Site <- factor(
  abundance_by_category$Site,
  levels = c("Eilat", "Tel Shikmona", "Plemmirio", "Capo Passero")
)

# Define colors for categories
category_colors <- c(
  "Shared_diatoms" = "#2E8B57",           # Sea green (cosmopolitan)
  "Mediterranean_only" = "#1F78B4",        # Blue
  "Sicily_only" = "#E31A1C",               # Red
  "Environmental_associated" = "#FF7F00",  # Orange
  "Other_associations" = "#999999"         # Gray
)


##############################################
# HIGHLY DILATED BOXPLOT WITH STYLED JITTER
##############################################



# Custom transformation - MORE EXAGGERATED
# 95-100% = top HALF (0.5-1.0)
# 80-95% = third quarter (0.25-0.5)  
# 0-80% = bottom quarter (0-0.25)

custom_trans_extreme <- function() {
  trans_new(
    name = "custom_extreme",
    transform = function(x) {
      # Map to three regions
      ifelse(x >= 95, 
             0.5 + (x - 95) / 10,      # 95-100 maps to 0.5-1.0 (top HALF)
             ifelse(x >= 80,
                    0.25 + (x - 80) / 60, # 80-95 maps to 0.25-0.5 (third quarter)
                    x / 320))             # 0-80 maps to 0-0.25 (bottom quarter)
    },
    inverse = function(y) {
      # Reverse mapping
      ifelse(y >= 0.5,
             95 + (y - 0.5) * 10,
             ifelse(y >= 0.25,
                    80 + (y - 0.25) * 60,
                    y * 320))
    },
    breaks = function(x) {
      c(0, 10, 20, 40, 60, 80, 85, 90, 95, 96, 97, 98, 99, 100)
    }
  )
}

# Create the plot with extreme dilation
plot_boxplot_extreme <- ggplot(abundance_by_category, 
                               aes(x = Site, y = percentage, fill = Association)) +
  # Boxplot without outliers
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +
  # Add jittered points with black outline
  geom_jitter(aes(fill = Association),
              position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.75),
              shape = 21,        # Filled circle with outline
              size = 3,          # Point size
              stroke = 0.5,      # Outline thickness
              color = "black",   # Outline color (black)
              alpha = 1) +       # Solid fill (no transparency)
  # Custom y-axis transformation
  scale_y_continuous(
    trans = custom_trans_extreme(),
    breaks = c(0, 10, 20, 40, 60, 80, 85, 90, 95, 96, 97, 98, 99, 100)
  ) +
  scale_fill_manual(values = category_colors, name = "Diatom Association") +
  # Add horizontal lines to show the three regions
  geom_hline(yintercept = 80, linetype = "dashed", color = "gray30", linewidth = 0.6) +
  geom_hline(yintercept = 95, linetype = "dashed", color = "gray30", linewidth = 0.6) +
  # Add region labels (optional)
  annotate("text", x = 0.5, y = 97.5, label = "95-100%\n(Top Half)", 
           hjust = 0, size = 3, fontface = "italic", color = "gray30") +
  annotate("text", x = 0.5, y = 87.5, label = "80-95%\n(Third Quarter)", 
           hjust = 0, size = 3, fontface = "italic", color = "gray30") +
  annotate("text", x = 0.5, y = 40, label = "0-80%\n(Bottom Quarter)", 
           hjust = 0, size = 3, fontface = "italic", color = "gray30") +
  labs(
    title = "Diatom Association Categories Across Localities",
    subtitle = "Y-axis highly dilated: 95-100% (top half), 80-95% (1/4), 0-80% (1/4)",
    x = "Locality",
    y = "Percentage of Diatom Community (%)"
  ) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.8),
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
    axis.text.y = element_text(size = 9),
    axis.title = element_text(size = 12, face = "bold"),
    legend.position = "right",
    legend.title = element_text(size = 11, face = "bold"),
    aspect.ratio = 0.5   
  )

# Save the plot
ggsave("../output/Figure_4/Figure_4B_Boxplot_Extreme_Dilation.pdf", 
       plot_boxplot_extreme, width = 16, height = 8, dpi = 300)


##############################################
##  FIGURE 4C: DIATOM ASV COMPOSITION       ##
##  (with Spectral palette)                 ##
##############################################

cat("\n=== Creating Figure 4C: Diatom ASV Composition ===\n")

# Step 1: Prepare data - filter for diatoms only and RECALCULATE PROPORTIONS
diatom_data <- ll.all.euk %>%
  dplyr::filter(Class == "Bacillariophyta") %>%
  dplyr::filter(Sample_type == "single_cell") %>%
  dplyr::select(ASV_ID, Extraction_Voucher, proportion_ASV, Site, Depth_cat, Substrate, Genus)

# CRITICAL: Recalculate proportions so diatoms sum to 1 within each sample
diatom_data <- diatom_data %>%
  dplyr::group_by(Extraction_Voucher) %>%
  dplyr::mutate(
    diatom_proportion = proportion_ASV / sum(proportion_ASV)
  ) %>%
  dplyr::ungroup()

# Verify proportions sum to 1
check_sums <- diatom_data %>%
  dplyr::group_by(Extraction_Voucher) %>%
  dplyr::summarize(total = sum(diatom_proportion), .groups = "drop")

if (any(abs(check_sums$total - 1) > 0.001)) {
  cat("WARNING: Some samples don't sum to 1!\n")
} else {
  cat("✓ All samples sum to 1 (diatoms only)\n")
}

# Step 2: Create genus labels (simplify names)
diatom_data <- diatom_data %>%
  dplyr::mutate(
    Genus_Label = dplyr::case_when(
      Genus == "Staurosirella_Nanofrustulum" ~ "Staurosirella_Nanofrustulum",
      Genus == "Nanofrustulum" ~ "Nanofrustulum",
      Genus == "Staurosira" ~ "Staurosira",
      Genus == "Stauroneis" ~ "Stauroneis",
      Genus == "Unclassified" ~ "Unclassified",
      TRUE ~ "Other"
    )
  )

# Step 3: Identify major ASVs (≥5% in at least one sample)
major_asvs <- diatom_data %>%
  dplyr::group_by(ASV_ID, Genus_Label) %>%
  dplyr::summarize(
    max_abundance = max(diatom_proportion),  # Use recalculated proportions
    .groups = "drop"
  ) %>%
  dplyr::filter(max_abundance >= 0.05) %>%
  dplyr::arrange(Genus_Label, desc(max_abundance))

cat("Major ASVs identified (≥5% in at least one sample):\n")
major_asv_counts <- major_asvs %>%
  dplyr::group_by(Genus_Label) %>%
  dplyr::summarize(n_ASVs = n(), .groups = "drop")
print(major_asv_counts)

# Step 4: Create plotting categories
diatom_plot_data <- diatom_data %>%
  dplyr::left_join(
    major_asvs %>% dplyr::select(ASV_ID, Genus_Label),
    by = c("ASV_ID", "Genus_Label"),
    relationship = "many-to-many"
  ) %>%
  dplyr::mutate(
    Plot_Category = dplyr::case_when(
      ASV_ID %in% major_asvs$ASV_ID ~ ASV_ID,
      TRUE ~ paste0(Genus_Label, "_minor")
    )
  )

# Step 5: Aggregate by plot category (using recalculated proportions)
diatom_aggregated <- diatom_plot_data %>%
  dplyr::group_by(Extraction_Voucher, Site, Depth_cat, Substrate, Plot_Category, Genus_Label) %>%
  dplyr::summarize(
    proportion = sum(diatom_proportion),  # Use recalculated proportions
    .groups = "drop"
  )

# Step 6: Order bars by abundance within each sample (lowest to highest for bottom-up stacking)
diatom_aggregated <- diatom_aggregated %>%
  dplyr::group_by(Extraction_Voucher) %>%
  dplyr::arrange(Extraction_Voucher, proportion) %>%
  dplyr::mutate(order = row_number()) %>%
  dplyr::ungroup()

# Step 7: Create facet label combining all factors
diatom_aggregated <- diatom_aggregated %>%
  dplyr::mutate(
    Facet_Label = paste0(Site, "\n", Substrate, " | ", Depth_cat)
  )

# Step 8: Load Spectral palette
spectral_full <- c("#A71B4BFF", "#AC214AFF", "#B12749FF", "#B52C48FF", "#BA3147FF", "#BE3645FF", 
                   "#C33B43FF", "#C74040FF", "#CC443DFF", "#D04939FF", "#D44E35FF", "#D8522FFF", 
                   "#DC5728FF", "#E05C1EFF", "#E4600EFF", "#E66606FF", "#E86C03FF", "#E97202FF", 
                   "#EB7803FF", "#EC7D06FF", "#EE830BFF", "#EF8811FF", "#F08D17FF", "#F1931EFF", 
                   "#F29824FF", "#F39D2AFF", "#F4A230FF", "#F5A736FF", "#F6AB3DFF", "#F7B043FF", 
                   "#F8B549FF", "#F8B94FFF", "#F9BE56FF", "#F9C25CFF", "#FAC762FF", "#FACB68FF", 
                   "#FBCF6FFF", "#FBD375FF", "#FCD77BFF", "#FCDB81FF", "#FCDF88FF", "#FDE38EFF", 
                   "#FDE794FF", "#FDEA9AFF", "#FEEEA0FF", "#FEF1A6FF", "#FEF4ABFF", "#FEF7B1FF", 
                   "#FEFAB7FF", "#FEFCBCFF", "#FBFDBDFF", "#F6FCBBFF", "#EFFBB9FF", "#E9F9B7FF", 
                   "#E2F8B5FF", "#DBF6B3FF", "#D4F5B2FF", "#CCF3B0FF", "#C5F1AFFF", "#BDEFAEFF", 
                   "#B5EDAEFF", "#ADEAADFF", "#A4E8ADFF", "#9CE5ADFF", "#93E3ADFF", "#8AE0ADFF", 
                   "#81DEADFF", "#78DBAEFF", "#6ED8AEFF", "#64D5AFFF", "#5AD2B0FF", "#4FCFB0FF", 
                   "#43CBB1FF", "#36C8B2FF", "#26C4B3FF", "#0FC1B3FF", "#00BDB4FF", "#00B9B4FF", 
                   "#00B6B5FF", "#00B2B5FF", "#00AEB6FF", "#00AAB6FF", "#00A5B6FF", "#00A1B6FF", 
                   "#009DB6FF", "#0098B5FF", "#0093B5FF", "#008FB4FF", "#008AB4FF", "#0085B3FF", 
                   "#0080B2FF", "#137AB0FF", "#2375AFFF", "#2E70ADFF", "#386AABFF", "#3F64A9FF", 
                   "#475EA7FF", "#4D58A5FF", "#5351A2FF", "#584B9FFF")

cat("Spectral palette loaded:", length(spectral_full), "colors\n")

# Step 9: Define color ranges for each genus
genus_color_ranges <- list(
  Unclassified = spectral_full[seq(1, 26, length.out = 25)],      # Reds through yellows
  Nanofrustulum = spectral_full[seq(45, 65, length.out = 18)],    # Greens through cyans
  Staurosira = spectral_full[seq(80, 90, length.out = 6)],        # Cyan-blues
  Staurosirella_Nanofrustulum = "#BAD871FF",                       # Single color
  Stauroneis = "#006228FF",                                        # Single color
  Other = "#999999"                                                # Grey
)

# Step 10: Generate color palette
generate_spectral_palette <- function(major_asvs_df, genus_color_ranges) {
  
  color_map <- c()
  
  for (genus in names(genus_color_ranges)) {
    
    # Get ASVs for this genus
    asvs_in_genus <- major_asvs_df %>% 
      dplyr::filter(Genus_Label == genus)
    
    if (nrow(asvs_in_genus) == 0) {
      # Just add the minor color
      minor_category <- paste0(genus, "_minor")
      if (length(genus_color_ranges[[genus]]) == 1) {
        # Single color - make it lighter for minor
        base_rgb <- col2rgb(genus_color_ranges[[genus]]) / 255
        light_rgb <- pmin(base_rgb * 1.5 + 0.3, 1)
        color_map[minor_category] <- rgb(light_rgb[1], light_rgb[2], light_rgb[3])
      }
      next
    }
    
    # Order by abundance (most abundant gets first color)
    asvs_in_genus <- asvs_in_genus %>% 
      dplyr::arrange(desc(max_abundance))
    
    n_asvs <- nrow(asvs_in_genus)
    colors_available <- genus_color_ranges[[genus]]
    
    if (length(colors_available) == 1) {
      # Single color for this genus
      color_map[asvs_in_genus$ASV_ID[1]] <- colors_available
    } else {
      # Multiple colors - assign sequentially
      if (n_asvs <= length(colors_available)) {
        selected_colors <- colors_available[seq(1, length(colors_available), length.out = n_asvs)]
      } else {
        selected_colors <- colorRampPalette(colors_available)(n_asvs)
      }
      
      for (i in 1:n_asvs) {
        color_map[asvs_in_genus$ASV_ID[i]] <- selected_colors[i]
      }
    }
    
    # Add very light shade for minor ASVs - use FIRST color (darkest)
    minor_category <- paste0(genus, "_minor")
    if (length(colors_available) > 1) {
      first_color_rgb <- col2rgb(colors_available[1]) / 255
      very_light_rgb <- pmin(first_color_rgb * 0.5 + 0.5, 1)
      color_map[minor_category] <- rgb(very_light_rgb[1], very_light_rgb[2], very_light_rgb[3])
    }
  }
  
  return(color_map)
}

# Generate the palette
asv_color_palette <- generate_spectral_palette(major_asvs, genus_color_ranges)

cat("Colors assigned:", length(asv_color_palette), "\n")

# Step 11: Create the plot with detailed faceting
figure_4c <- ggplot(diatom_aggregated, 
                    aes(x = Extraction_Voucher, y = proportion, 
                        fill = Plot_Category, order = order)) +
  geom_bar(stat = "identity", position = "stack", color = "black", linewidth = 0.2) +
  scale_fill_manual(values = asv_color_palette, 
                    name = "Diatom ASVs",
                    guide = "none") +  # No legend in main plot
  facet_wrap(~ Facet_Label, scales = "free_x", ncol = 4) +
  labs(
    title = "Diatom Symbiont Composition at ASV Level",
    subtitle = "Each bar represents one foraminifer specimen (proportions sum to 100% within each sample)",
    x = "Sample",
    y = "Relative Abundance (Diatoms only)"
  ) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.8),
    strip.background = element_rect(fill = "grey90", color = "black"),
    strip.text = element_text(size = 8, face = "bold"),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_text(size = 10),
    axis.title = element_text(size = 11, face = "bold"),
    plot.title = element_text(hjust = 0.5, size = 13, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    legend.position = "none"
  )

# Save main figure
ggsave("../output/Figure_4/Figure_4C_Diatom_ASV_Composition_Spectral.pdf", 
       figure_4c, width = 16, height = 12, dpi = 300)

cat("✓ Figure 4C saved\n")

# Step 12: Create and export color palette as a figure
cat("Creating color palette legend figure...\n")

# Prepare palette data for visualization
palette_data <- data.frame(
  Plot_Category = names(asv_color_palette),
  Color = asv_color_palette,
  stringsAsFactors = FALSE
) %>%
  dplyr::left_join(
    major_asvs %>% 
      dplyr::select(ASV_ID, Genus_Label) %>%
      dplyr::rename(Plot_Category = ASV_ID),
    by = "Plot_Category"
  ) %>%
  dplyr::mutate(
    Genus_Label = ifelse(is.na(Genus_Label), 
                         gsub("_minor", "", Plot_Category), 
                         Genus_Label),
    Label = Plot_Category,
    y_position = row_number()
  ) %>%
  dplyr::arrange(Genus_Label, Plot_Category)

# Create visual palette figure
palette_figure <- ggplot(palette_data, aes(x = 1, y = y_position, fill = Plot_Category)) +
  geom_tile(color = "black", linewidth = 0.5, width = 0.8, height = 0.8) +
  geom_text(aes(x = 2, label = paste(Label, "-", Genus_Label)), 
            hjust = 0, size = 3) +
  scale_fill_manual(values = asv_color_palette) +
  xlim(0.5, 8) +
  labs(
    title = "Figure 4C Color Palette",
    subtitle = "Spectral palette for diatom ASV visualization"
  ) +
  theme_void() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 11),
    legend.position = "none",
    plot.margin = margin(10, 10, 10, 10)
  )

# Save palette figure
ggsave("../output/Figure_4/Figure_4C_Color_Palette_Legend.pdf", 
       palette_figure, width = 10, height = 20, dpi = 300)

cat("✓ Color palette legend saved\n")

##############################################
##############################################
##                                          ##
##           FUNCTIONAL PROFILING           ##
##     ANALYSIS OF PROKARYOTIC COMMUNITIES  ##
##                                          ##
##############################################
##############################################

##############################################
#    PREPARE AND EXPORT FAPROTAX INPUT      #
#    (SUPPLEMENTARY MATERIAL S7)            #
##############################################

cat("\n=== PREPARING FAPROTAX INPUT (Table S7) ===\n")

# 1. Create ASV table with proportions and full taxonomic paths
# Use pro.asv.merged (cleaned data after filtering)
faprotax_asv_table <- pro.asv.merged %>%
  as.matrix() %>% 
  prop.table(margin = 2) %>%  # Recalculate proportions per sample
  as.data.frame() %>%
  tibble::rownames_to_column(var = "ASV_ID") %>%
  # Add taxonomy from original table
  dplyr::left_join(
    PRO_TAXONOMY %>%
      tidyr::unite("Taxonomy_path", Kingdom, Phylum, Class, Order, Family, Genus, sep = ";") %>%
      tibble::rownames_to_column(var = "ASV_ID") %>% 
      dplyr::select(ASV_ID, Taxonomy_path),
    by = "ASV_ID"
  ) %>%
  # Create full taxonomic path with ASV ID (FAPROTAX format: ASV_ID;Kingdom;Phylum;...)
  tidyr::unite("Taxonomy", ASV_ID, Taxonomy_path, sep = ";") %>%
  # Move Taxonomy column to first position
  dplyr::relocate(Taxonomy)

cat("FAPROTAX input table prepared:\n")
cat("  Dimensions:", nrow(faprotax_asv_table), "ASVs ×", ncol(faprotax_asv_table) - 1, "samples\n")
cat("  Format: Proportions (samples sum to 1)\n")

# Export as Table S7
write.table(faprotax_asv_table, 
            file = "../output/Supplementary_Tables/Table_S7_FAPROTAX_Input_Taxonomy.tsv",
            sep = "\t",
            quote = FALSE,
            row.names = FALSE,
            col.names = TRUE)

cat("✓ Table S7 exported: FAPROTAX input with taxonomic paths\n")

# Preview first few rows
cat("\nPreview of FAPROTAX input format:\n")
print(head(faprotax_asv_table[, 1:5]))

cat("\n=== FAPROTAX INPUT PREPARATION COMPLETE ===\n")
cat("This file was used as input to FAPROTAX version 1.2.7\n")
cat("Command: collapse_table.py --omit_unrepresented_groups --group_leftovers_as Unassigned\n")
cat("         --normalize_collapsed columns_before_collapsing_excluding_unassigned\n\n")

##############################################
##############################################
##                                          ##
##     FIGURE 5: FUNCTIONAL PROFILING       ##
##     ANALYSIS OF PROKARYOTIC COMMUNITIES  ##
##                                          ##
##############################################
##############################################

# This script performs functional profiling analysis using FAPROTAX output
# Generates Figure 5 (A, B, C) and supplementary figures S6 and S7

cat("Starting functional profiling analysis...\n")

##############################################
##  SECTION 1: LOAD AND PROCESS FAPROTAX   ##
##############################################

cat("\n=== SECTION 1: Loading FAPROTAX output ===\n")

# Load FAPROTAX functional table
FUNCTIONAL_PROFILING <- read.table("../data/Supplementary_Material_S7.txt", 
                                   header = TRUE, 
                                   sep = "\t")

cat("FAPROTAX output dimensions:", dim(FUNCTIONAL_PROFILING), "\n")
cat("Functions detected:", nrow(FUNCTIONAL_PROFILING), "\n")
cat("Samples:", ncol(FUNCTIONAL_PROFILING) - 1, "\n")

# Load FAPROTAX report
report_lines <- readLines("../data/Supplementary_Material_S8.txt")

##############################################
##   SECTION 2: REMOVE PARENT FUNCTIONS     ##
##############################################

cat("\n=== SECTION 2: Removing hierarchical parent functions ===\n")

# Define parent functions to remove
parent_functions_to_remove <- c(
  "methylotrophy",
  "nitrification",
  "respiration_of_sulfur_compounds",
  "dark_oxidation_of_sulfur_compounds",
  "denitrification",
  "hydrocarbon_degradation",
  "nitrogen_respiration",
  "photoautotrophy",
  "phototrophy",
  "anoxygenic_photoautotrophy",
  "oxygenic_photoautotrophy",
  "chemoheterotrophy"
)

cat("Removing", length(parent_functions_to_remove), "parent functions\n")

# Remove parent functions
FUNCTIONAL_PROFILING_CURATED <- FUNCTIONAL_PROFILING %>%
  dplyr::filter(!group %in% parent_functions_to_remove)

cat("Functions after curation:", nrow(FUNCTIONAL_PROFILING_CURATED), "\n")
cat("(Including 'Unassigned' category)\n")

# Transpose and format
func_temp <- FUNCTIONAL_PROFILING_CURATED
rownames(func_temp) <- func_temp$group
func_temp <- func_temp %>% dplyr::select(-group)
func_temp <- t(func_temp)

functional_data <- as.data.frame(func_temp) %>%
  tibble::rownames_to_column(var = "Extraction_Voucher")

# Join with metadata
functional_data_meta <- functional_data %>%
  dplyr::left_join(PRO_META_FORMATED, by = "Extraction_Voucher") %>%
  dplyr::mutate(Sample_type = factor(Sample_type,
                                     levels = c("single_cell", "sediment", "filter"),
                                     labels = c("Foraminifera", "Sediment", "Seawater")))

cat("Functional data prepared with metadata\n")

##############################################
##  SECTION 3: CALCULATE ASSIGNMENT RATES  ##
##  (FIGURE S6) - CORRECTED                ##
##############################################

cat("\n=== SECTION 3: Calculating functional assignment rates (Figure S6) ===\n")

# Extract ASV IDs from FAPROTAX report
# Find all ASV lines (exclude Unassigned section)
unassigned_section_start <- grep("^# Unassigned \\(", report_lines)
functional_section_end <- unassigned_section_start - 1

# Get ASVs assigned to functions (before Unassigned section)
functional_lines <- report_lines[1:functional_section_end]
functional_asv_lines <- grep("^    sq[0-9]+;", functional_lines, value = TRUE)
assigned_asvs <- unique(sub("^    (sq[0-9]+);.*", "\\1", functional_asv_lines))

# Get unassigned ASVs (from Unassigned section)
unassigned_lines <- report_lines[(unassigned_section_start + 1):length(report_lines)]
unassigned_asv_lines <- grep("^    sq[0-9]+;", unassigned_lines, value = TRUE)
unassigned_asvs <- unique(sub("^    (sq[0-9]+);.*", "\\1", unassigned_asv_lines))

cat("ASVs assigned to functions:", length(assigned_asvs), "\n")
cat("ASVs unassigned:", length(unassigned_asvs), "\n")

# Extract numeric columns from faprotax_asv_table
numeric_cols <- sapply(faprotax_asv_table, is.numeric)
faprotax_asv_counts <- faprotax_asv_table[, numeric_cols]

# Extract ASV IDs from the Taxonomy column
asv_ids_in_table <- sub("(sq[0-9]+);.*", "\\1", faprotax_asv_table$Taxonomy)

cat("ASVs in table:", length(asv_ids_in_table), "\n")
cat("Matches to assigned ASVs:", sum(asv_ids_in_table %in% assigned_asvs), "\n")
cat("Matches to unassigned ASVs:", sum(asv_ids_in_table %in% unassigned_asvs), "\n")

# Calculate assignment rates per sample
assignment_by_sample <- data.frame(
  Extraction_Voucher = colnames(faprotax_asv_counts),
  Assigned_reads = 0,
  Unassigned_reads = 0,
  Total_reads = 0,
  Assigned_perc = 0,
  Unassigned_perc = 0,
  stringsAsFactors = FALSE
)

for (i in 1:ncol(faprotax_asv_counts)) {
  sample_counts <- faprotax_asv_counts[, i]
  
  total_reads <- sum(sample_counts)
  assigned_reads <- sum(sample_counts[asv_ids_in_table %in% assigned_asvs])
  unassigned_reads <- sum(sample_counts[asv_ids_in_table %in% unassigned_asvs])
  
  assignment_by_sample$Assigned_reads[i] <- assigned_reads
  assignment_by_sample$Unassigned_reads[i] <- unassigned_reads
  assignment_by_sample$Total_reads[i] <- total_reads
  
  if (total_reads > 0) {
    assignment_by_sample$Assigned_perc[i] <- (assigned_reads / total_reads) * 100
    assignment_by_sample$Unassigned_perc[i] <- (unassigned_reads / total_reads) * 100
  }
}

# Join with metadata
assignment_by_sample <- assignment_by_sample %>%
  dplyr::left_join(PRO_META_FORMATED, by = "Extraction_Voucher") %>%
  dplyr::mutate(Sample_type = factor(Sample_type,
                                     levels = c("single_cell", "sediment", "filter"),
                                     labels = c("Foraminifera", "Sediment", "Seawater")))

# Summary statistics
assignment_summary <- assignment_by_sample %>%
  dplyr::group_by(Sample_type) %>%
  summarise(
    n = n(),
    Mean_Assigned_perc = mean(Assigned_perc),
    SD_Assigned_perc = sd(Assigned_perc),
    Mean_Unassigned_perc = mean(Unassigned_perc),
    SD_Unassigned_perc = sd(Unassigned_perc)
  )

cat("\nAssignment rate summary:\n")
print(assignment_summary)

# Statistical test
kruskal_test <- kruskal.test(Assigned_perc ~ Sample_type, data = assignment_by_sample)
cat("\nKruskal-Wallis test: H =", round(kruskal_test$statistic, 3), 
    ", p =", format.pval(kruskal_test$p.value, digits = 3), "\n")

# FIGURE S6: Boxplot of assignment rates
plot_data_assignment <- assignment_by_sample %>%
  dplyr::select(Sample_type, Assigned_perc, Unassigned_perc) %>%
  tidyr::pivot_longer(cols = c(Assigned_perc, Unassigned_perc),
                      names_to = "Category",
                      values_to = "Percentage") %>%
  dplyr::mutate(Category = factor(Category,
                                  levels = c("Assigned_perc", "Unassigned_perc"),
                                  labels = c("Assigned to functions", "Unassigned")))

figure_s6 <- ggplot(plot_data_assignment,
                    aes(x = Sample_type, y = Percentage, fill = Category)) +
  geom_boxplot(outlier.size = 1, alpha = 0.8) +
  scale_fill_manual(
    values = c("Assigned to functions" = "#27AE60", 
               "Unassigned" = "#E74C3C"),
    name = ""
  ) +
  labs(
    title = "FAPROTAX functional assignment rate",
    x = "Sample type",
    y = "Percentage of reads (%)"
  ) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.8),
    panel.grid.major.x = element_blank(),
    legend.position = "bottom",
    plot.title = element_text(size = 11, hjust = 0.5, face = "bold"),
    axis.text = element_text(size = 9),
    axis.title = element_text(size = 10)
  )

ggsave("../output/Figure_S6/Figure_S6_Assignment_Rates.pdf", 
       figure_s6, width = 8, height = 6, dpi = 300)

cat("✓ Saved: Figure_S6_Assignment_Rates.pdf\n")

##############################################
##  SECTION 4: PREPARE DATA FOR NMDS       ##
##  (EXCLUDE UNASSIGNED)                   ##
##############################################

cat("\n=== SECTION 4: Preparing data for NMDS (excluding Unassigned) ===\n")

# Remove Unassigned for NMDS
FUNCTIONAL_PROFILING_FOR_NMDS <- FUNCTIONAL_PROFILING_CURATED %>%
  dplyr::filter(group != "Unassigned")

cat("Functions for NMDS:", nrow(FUNCTIONAL_PROFILING_FOR_NMDS), "\n")

# Process for NMDS
func_temp_nmds <- FUNCTIONAL_PROFILING_FOR_NMDS
rownames(func_temp_nmds) <- func_temp_nmds$group
func_temp_nmds <- func_temp_nmds %>% dplyr::select(-group)
func_temp_nmds <- t(func_temp_nmds)

functional_data_nmds <- as.data.frame(func_temp_nmds) %>%
  tibble::rownames_to_column(var = "Extraction_Voucher")

# Join with metadata
functional_data_meta_nmds <- functional_data_nmds %>%
  dplyr::left_join(PRO_META_FORMATED, by = "Extraction_Voucher") %>%
  dplyr::mutate(Sample_type = factor(Sample_type,
                                     levels = c("single_cell", "sediment", "filter"),
                                     labels = c("Foraminifera", "Sediment", "Seawater")))

# Function to prepare multivariate data
prepare_functional_mv <- function(func_data_with_meta) {
  metadata_cols <- c("Extraction_Voucher", "Site", "Depth", "Depth_cat", "Sample_type", "Substrate")
  function_cols <- setdiff(names(func_data_with_meta), metadata_cols)
  
  community_matrix <- func_data_with_meta %>%
    dplyr::select(dplyr::all_of(function_cols)) %>%
    as.data.frame()
  
  # Remove any non-numeric columns
  numeric_cols <- sapply(community_matrix, is.numeric)
  if (sum(!numeric_cols) > 0) {
    cat("  Removing non-numeric columns:", names(community_matrix)[!numeric_cols], "\n")
    community_matrix <- community_matrix[, numeric_cols]
  }
  
  metadata_subset <- func_data_with_meta %>%
    dplyr::select(any_of(c("Extraction_Voucher", "Site", "Depth_cat", "Sample_type", "Substrate")))
  
  rownames(community_matrix) <- metadata_subset$Extraction_Voucher
  rownames(metadata_subset) <- metadata_subset$Extraction_Voucher
  
  return(list(
    community = community_matrix,
    metadata = metadata_subset
  ))
}

##############################################
##  SECTION 5: NMDS ALL SAMPLE TYPES       ##
##  (FIGURE 5A)                            ##
##############################################

cat("\n=== SECTION 5: NMDS with all sample types (Figure 5A) ===\n")

# Prepare data
func_mv_all <- prepare_functional_mv(functional_data_meta_nmds)

cat("Community matrix:", nrow(func_mv_all$community), "samples ×", 
    ncol(func_mv_all$community), "functions\n")

# NMDS ordination
cat("Running NMDS...\n")
set.seed(123)  # For reproducibility
func_nmds_all <- metaMDS(func_mv_all$community, distance = "bray", k = 2, 
                         try = 100, trace = FALSE)

cat("NMDS stress:", round(func_nmds_all$stress, 3), "\n")

# Extract scores
func_nmds_scores_all <- as.data.frame(scores(func_nmds_all)$sites) %>%
  tibble::rownames_to_column(var = "Extraction_Voucher") %>%
  dplyr::left_join(func_mv_all$metadata, by = "Extraction_Voucher")

# ANOSIM
cat("Running ANOSIM...\n")
func_anosim_all <- anosim(func_mv_all$community, 
                          func_mv_all$metadata$Sample_type,
                          distance = "bray", permutations = 999)

# Betadispersion
cat("Running betadispersion test...\n")
func_bray_all <- vegdist(func_mv_all$community, method = "bray")
func_betadisp_all <- betadisper(func_bray_all, func_mv_all$metadata$Sample_type)
func_betadisp_test_all <- permutest(func_betadisp_all, permutations = 999)

# Print results
cat("\n--- RESULTS (All sample types) ---\n")
cat("NMDS Stress:", round(func_nmds_all$stress, 3), "\n")
cat("ANOSIM R:", round(func_anosim_all$statistic, 3), 
    "| p =", func_anosim_all$signif, "\n")
cat("Betadispersion F:", round(func_betadisp_test_all$tab$F[1], 3),
    "| p =", func_betadisp_test_all$tab$`Pr(>F)`[1], "\n")

# FIGURE 5A: NMDS plot
figure_5a <- ggplot(func_nmds_scores_all, aes(x = NMDS1, y = NMDS2)) +
  geom_point(aes(fill = Site, shape = Sample_type), 
             size = 5, color = "black", stroke = 1) +
  scale_fill_viridis_d(name = "Site", option = "viridis") +
  scale_shape_manual(
    values = c("Foraminifera" = 22, "Sediment" = 23, "Seawater" = 25),
    name = "Sample type"
  ) +
  labs(
    title = "Functional profiles across sample types",
    subtitle = paste0("Stress = ", round(func_nmds_all$stress, 3),
                      " | ANOSIM R = ", round(func_anosim_all$statistic, 3),
                      " (p = ", func_anosim_all$signif, ")")
  ) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.8),
    legend.text = element_text(size = 8),
    legend.title = element_text(size = 9),
    axis.text = element_text(size = 8),
    axis.title = element_text(size = 9),
    plot.title = element_text(size = 10, hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(size = 9, hjust = 0.5),
    aspect.ratio = 1
  )

ggsave("../output/Figure_5/Figure_5A_NMDS_All_Samples.pdf", 
       figure_5a, width = 7, height = 6, dpi = 300)

cat("✓ Saved: Figure_5A_NMDS_All_Samples.pdf\n")

##############################################
##  SECTION 6: NMDS FORAMINIFERA ONLY      ##
##  (FIGURE 5B)                            ##
##############################################

cat("\n=== SECTION 6: NMDS with foraminifera only (Figure 5B) ===\n")

# Filter to foraminifera
functional_foram_nmds <- functional_data_meta_nmds %>%
  dplyr::filter(Sample_type == "Foraminifera")

cat("Foraminifera samples:", nrow(functional_foram_nmds), "\n")

# Prepare data
func_foram_mv <- prepare_functional_mv(functional_foram_nmds)

# Remove zero-sum columns
non_zero_cols <- colSums(func_foram_mv$community) > 0
func_foram_mv$community <- func_foram_mv$community[, non_zero_cols]

cat("Functions present in foraminifera:", ncol(func_foram_mv$community), "\n")

# NMDS
cat("Running NMDS...\n")
set.seed(123)
func_nmds_foram <- metaMDS(func_foram_mv$community, distance = "bray", 
                           k = 2, try = 100, trace = FALSE)

cat("NMDS stress:", round(func_nmds_foram$stress, 3), "\n")

# Extract scores
func_nmds_scores_foram <- as.data.frame(scores(func_nmds_foram)$sites) %>%
  tibble::rownames_to_column(var = "Extraction_Voucher") %>%
  dplyr::left_join(func_foram_mv$metadata, by = "Extraction_Voucher")

# PERMANOVA
cat("Running PERMANOVA...\n")
func_permanova_foram <- adonis2(
  func_foram_mv$community ~ Site * Depth_cat * Substrate,
  data = func_foram_mv$metadata,
  permutations = 999,
  method = "bray",
  by = "terms"
)

# Betadispersion tests
func_bray_foram <- vegdist(func_foram_mv$community, method = "bray")

func_betadisp_site <- betadisper(func_bray_foram, func_foram_mv$metadata$Site)
func_betadisp_test_site <- permutest(func_betadisp_site, permutations = 999)

func_betadisp_depth <- betadisper(func_bray_foram, func_foram_mv$metadata$Depth_cat)
func_betadisp_test_depth <- permutest(func_betadisp_depth, permutations = 999)

func_betadisp_substrate <- betadisper(func_bray_foram, func_foram_mv$metadata$Substrate)
func_betadisp_test_substrate <- permutest(func_betadisp_substrate, permutations = 999)

# Print results
cat("\n--- RESULTS (Foraminifera only) ---\n")
cat("NMDS Stress:", round(func_nmds_foram$stress, 3), "\n")
cat("\nPERMANOVA:\n")
print(func_permanova_foram)
cat("\nBetadispersion tests:\n")
cat("Site - F:", round(func_betadisp_test_site$tab$F[1], 3),
    "| p =", func_betadisp_test_site$tab$`Pr(>F)`[1], "\n")
cat("Depth - F:", round(func_betadisp_test_depth$tab$F[1], 3),
    "| p =", func_betadisp_test_depth$tab$`Pr(>F)`[1], "\n")
cat("Substrate - F:", round(func_betadisp_test_substrate$tab$F[1], 3),
    "| p =", func_betadisp_test_substrate$tab$`Pr(>F)`[1], "\n")

# FIGURE 5B: NMDS plot
figure_5b <- ggplot(func_nmds_scores_foram, aes(x = NMDS1, y = NMDS2)) +
  geom_point(aes(fill = Site, shape = Substrate, size = Depth_cat), 
             color = "black", stroke = 1) +
  scale_fill_viridis_d(name = "Site", option = "viridis") +
  scale_shape_manual(
    values = c(21, 24),
    name = "Substrate",
    labels = c("Algae", "Rubbles")
  ) +
  scale_size_manual(
    values = c("Deep" = 3, "Shallow" = 6),
    name = "Depth"
  ) +
  labs(
    title = "Functional profiles in foraminifera",
    subtitle = paste("Stress =", round(func_nmds_foram$stress, 3))
  ) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.8),
    legend.text = element_text(size = 8),
    legend.title = element_text(size = 9),
    axis.text = element_text(size = 8),
    axis.title = element_text(size = 9),
    plot.title = element_text(size = 10, hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(size = 9, hjust = 0.5),
    aspect.ratio = 1,
    legend.position = "right"
  )

ggsave("../output/Figure_5/Figure_5B_NMDS_Foraminifera.pdf", 
       figure_5b, width = 8, height = 6, dpi = 300)

cat("✓ Saved: Figure_5B_NMDS_Foraminifera.pdf\n")

##############################################
##  SECTION 7: DIFFERENTIAL ABUNDANCE       ##
##  (FIGURE 5C - OVERALL VOLCANO PLOT)     ##
##############################################

cat("\n=== SECTION 7: Differential abundance analysis (Figure 5C) ===\n")

# Calculate mean abundance per sample type for each function
function_by_type <- functional_data_meta %>%
  dplyr::select(-Extraction_Voucher, -Site, -any_of(c("Depth", "Depth_cat")), -Substrate) %>%
  tidyr::pivot_longer(cols = -Sample_type, 
                      names_to = "Function", 
                      values_to = "Abundance") %>%
  dplyr::group_by(Sample_type, Function) %>%
  summarise(Mean_Abundance = mean(Abundance, na.rm = TRUE),
            .groups = "drop")

# Calculate enrichment: Foram vs. mean(Sediment + Seawater)
enrichment_foram <- function_by_type %>%
  tidyr::pivot_wider(names_from = Sample_type, values_from = Mean_Abundance) %>%
  dplyr::filter(Function != "Unassigned") %>%
  dplyr::mutate(
    Environment_Mean = (Sediment + Seawater) / 2,
    Fold_Change = Foraminifera / Environment_Mean,
    Log2_FC = log2(Fold_Change + 0.0001),
    Enrichment_Category = case_when(
      Fold_Change > 2 ~ "Foram-enriched (>2×)",
      Fold_Change < 0.5 ~ "Foram-depleted (<0.5×)",
      TRUE ~ "Similar (0.5-2×)"
    )
  ) %>%
  dplyr::filter(!is.na(Fold_Change), is.finite(Fold_Change), Foraminifera > 0.001)

cat("Functions analyzed:", nrow(enrichment_foram), "\n")
cat("Foram-enriched (>2×):", sum(enrichment_foram$Enrichment_Category == "Foram-enriched (>2×)"), "\n")
cat("Foram-depleted (<0.5×):", sum(enrichment_foram$Enrichment_Category == "Foram-depleted (<0.5×)"), "\n")

# FIGURE 5C: Volcano plot (overall)
figure_5c <- ggplot(enrichment_foram, aes(x = Log2_FC, y = Foraminifera)) +
  geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = "grey50") +
  geom_point(aes(color = Enrichment_Category), size = 6) +
  geom_text_repel(
    data = enrichment_foram %>% dplyr::filter(abs(Log2_FC) > 0.05 | Foraminifera > 0.05),
    aes(label = Function),
    size = 3,
    max.overlaps = Inf,
    box.padding = 0.5,
    point.padding = 0.3,
    force = 2,
    segment.size = 0.2
  ) +
  scale_color_manual(
    values = c("Foram-enriched (>2×)" = "#E74C3C",
               "Similar (0.5-2×)" = "grey70",
               "Foram-depleted (<0.5×)" = "#3498DB"),
    name = ""
  ) +
  scale_y_log10() +
  labs(
    title = "Functional enrichment in foraminifera",
    subtitle = "Foraminifera vs. environment (sediment + seawater)",
    x = "Log₂(Fold Change)\nForaminifera / Environment",
    y = "Mean relative abundance in foraminifera (log scale)"
  ) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.8),
    legend.position = "bottom",
    plot.title = element_text(size = 11, hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(size = 9, hjust = 0.5)
  )

ggsave("../output/Figure_5/Figure_5C_Volcano_Overall.pdf", 
       figure_5c, width = 12, height = 10, dpi = 300)

cat("✓ Saved: Figure_5C_Volcano_Overall.pdf\n")

# Print top enriched/depleted
cat("\n--- Top 10 Foram-enriched functions ---\n")
top_enriched <- enrichment_foram %>%
  dplyr::filter(Enrichment_Category == "Foram-enriched (>2×)") %>%
  dplyr::arrange(desc(Fold_Change)) %>%
  head(10) %>%
  dplyr::select(Function, Foraminifera, Environment_Mean, Fold_Change, Log2_FC)
print(top_enriched)

cat("\n--- Top 10 Foram-depleted functions ---\n")
top_depleted <- enrichment_foram %>%
  dplyr::filter(Enrichment_Category == "Foram-depleted (<0.5×)") %>%
  dplyr::arrange(Fold_Change) %>%
  head(10) %>%
  dplyr::select(Function, Foraminifera, Environment_Mean, Fold_Change, Log2_FC)
print(top_depleted)

# Print top enriched/depleted
cat("\n--- Top 10 Foram-enriched functions ---\n")
top_enriched <- enrichment_foram %>%
  dplyr::filter(Enrichment_Category == "Foram-enriched (>2x)") %>%
  dplyr::arrange(desc(Fold_Change)) %>%
  head(10) %>%
  dplyr::select(Function, Foraminifera, Environment_Mean, Fold_Change, Log2_FC)
print(top_enriched)

cat("\n--- Top 10 Foram-depleted functions ---\n")
top_depleted <- enrichment_foram %>%
  dplyr::filter(Enrichment_Category == "Foram-depleted (<0.5x)") %>%
  dplyr::arrange(Fold_Change) %>%
  head(10) %>%
  dplyr::select(Function, Foraminifera, Environment_Mean, Fold_Change, Log2_FC)
print(top_depleted)

##############################################
##  SECTION 8: SITE-SPECIFIC VOLCANO PLOTS ##
##  (FIGURE S7)                            ##
##############################################

cat("\n=== SECTION 8: Site-specific enrichment analysis (Figure S7) ===\n")

# Calculate enrichment for each site separately
enrichment_by_site <- functional_data_meta %>%
  dplyr::select(-Extraction_Voucher) %>%
  dplyr::filter(!is.na(Site)) %>%
  tidyr::pivot_longer(cols = -c(Sample_type, Site, any_of(c("Depth", "Depth_cat")), Substrate),
                      names_to = "Function",
                      values_to = "Abundance") %>%
  dplyr::group_by(Site, Sample_type, Function) %>%
  summarise(Mean_Abundance = mean(Abundance, na.rm = TRUE),
            .groups = "drop")

# Calculate fold-change per site
enrichment_per_site <- enrichment_by_site %>%
  tidyr::pivot_wider(names_from = Sample_type, values_from = Mean_Abundance) %>%
  dplyr::filter(Function != "Unassigned") %>%
  dplyr::mutate(
    Environment_Mean = (Sediment + Seawater) / 2,
    Fold_Change = Foraminifera / Environment_Mean,
    Log2_FC = log2(Fold_Change + 0.0001),
    Enrichment_Category = case_when(
      Fold_Change > 2 ~ "Foram-enriched (>2×)",
      Fold_Change < 0.5 ~ "Foram-depleted (<0.5×)",
      TRUE ~ "Similar (0.5-2×)"
    )
  ) %>%
  dplyr::filter(!is.na(Fold_Change), is.finite(Fold_Change), Foraminifera > 0.001)

# Create volcano plot for each site
sites <- unique(enrichment_per_site$Site)

for (site in sites) {
  
  cat("\nProcessing site:", site, "\n")
  
  site_data <- enrichment_per_site %>% dplyr::filter(Site == site)
  
  volcano_site <- ggplot(site_data, aes(x = Log2_FC, y = Foraminifera)) +
    geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = "grey50") +
    geom_point(aes(color = Enrichment_Category), size = 3, alpha = 0.7) +
    geom_text_repel(
      data = site_data %>% dplyr::filter(abs(Log2_FC) > 0.05 | Foraminifera > 0.05),
      aes(label = Function),
      size = 3,
      max.overlaps = Inf,
      box.padding = 0.5,
      point.padding = 0.3,
      force = 2,
      segment.size = 0.2
    ) +
    scale_color_manual(
      values = c("Foram-enriched (>2×)" = "#E74C3C",
                 "Similar (0.5-2×)" = "grey70",
                 "Foram-depleted (<0.5×)" = "#3498DB"),
      name = ""
    ) +
    scale_y_log10() +
    labs(
      title = paste("Functional enrichment:", site),
      subtitle = "Foraminifera vs. environment",
      x = "Log₂(Fold Change)\nForaminifera / Environment",
      y = "Mean relative abundance in foraminifera (log scale)"
    ) +
    theme_minimal() +
    theme(
      panel.border = element_rect(color = "black", fill = NA, linewidth = 0.8),
      legend.position = "bottom",
      plot.title = element_text(size = 11, hjust = 0.5, face = "bold"),
      plot.subtitle = element_text(size = 9, hjust = 0.5)
    )
  
  filename <- paste0("../output/Figure_S7/Figure_S7_", gsub(" ", "_", site), ".pdf")
  ggsave(filename, volcano_site, width = 12, height = 10, dpi = 300)
  
  cat("✓ Saved:", filename, "\n")
}

# Multi-panel comparison
cat("\nCreating multi-panel comparison...\n")

volcano_faceted <- ggplot(enrichment_per_site, 
                          aes(x = Log2_FC, y = Foraminifera)) +
  geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = "grey50") +
  geom_point(aes(color = Enrichment_Category), size = 2, alpha = 0.7) +
  geom_text_repel(
    data = enrichment_per_site %>% 
      dplyr::filter(abs(Log2_FC) > 2 | Foraminifera > 0.1),
    aes(label = Function),
    size = 2,
    max.overlaps = 10,
    box.padding = 0.3,
    point.padding = 0.2,
    force = 1,
    segment.size = 0.2
  ) +
  facet_wrap(~ Site, ncol = 2) +
  scale_color_manual(
    values = c("Foram-enriched (>2×)" = "#E74C3C",
               "Similar (0.5-2×)" = "grey70",
               "Foram-depleted (<0.5×)" = "#3498DB"),
    name = ""
  ) +
  scale_y_log10() +
  labs(
    title = "Functional enrichment across sites",
    x = "Log₂(Fold Change)",
    y = "Mean relative abundance in foraminifera (log scale)"
  ) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.8),
    strip.background = element_rect(fill = "grey90", color = "black"),
    strip.text = element_text(face = "bold", size = 10),
    legend.position = "bottom"
  )

ggsave("../output/Figure_S7/Figure_S7_All_Sites_Faceted.pdf", 
       volcano_faceted, width = 14, height = 12, dpi = 300)

cat("✓ Saved: Figure_S7_All_Sites_Faceted.pdf\n")

# Consistency analysis
consistency_analysis <- enrichment_per_site %>%
  dplyr::group_by(Function) %>%
  summarise(
    N_Sites = n(),
    N_Enriched = sum(Enrichment_Category == "Foram-enriched (>2×)"),
    N_Depleted = sum(Enrichment_Category == "Foram-depleted (<0.5×)"),
    Mean_Log2FC = mean(Log2_FC, na.rm = TRUE),
    SD_Log2FC = sd(Log2_FC, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  dplyr::mutate(
    Consistency = case_when(
      N_Enriched == N_Sites ~ "Consistently enriched",
      N_Depleted == N_Sites ~ "Consistently depleted",
      N_Enriched >= N_Sites - 1 ~ "Mostly enriched",
      N_Depleted >= N_Sites - 1 ~ "Mostly depleted",
      TRUE ~ "Variable"
    )
  ) %>%
  dplyr::arrange(desc(N_Enriched), desc(Mean_Log2FC))

cat("\n--- Consistency across sites ---\n")
cat("Consistently enriched (all 4 sites):", 
    sum(consistency_analysis$Consistency == "Consistently enriched"), "\n")
cat("Mostly enriched (3+ sites):", 
    sum(consistency_analysis$Consistency == "Mostly enriched"), "\n")

write.csv(consistency_analysis, 
          "../output/Figure_S7/Function_Consistency_Across_Sites.csv",
          row.names = FALSE)

cat("✓ Saved: Function_Consistency_Across_Sites.csv\n")

# Consistency analysis
consistency_analysis <- enrichment_per_site %>%
  dplyr::group_by(Function) %>%
  summarise(
    N_Sites = n(),
    N_Enriched = sum(Enrichment_Category == "Foram-enriched (>2x)"),
    N_Depleted = sum(Enrichment_Category == "Foram-depleted (<0.5x)"),
    Mean_Log2FC = mean(Log2_FC, na.rm = TRUE),
    SD_Log2FC = sd(Log2_FC, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  dplyr::mutate(
    Consistency = case_when(
      N_Enriched == N_Sites ~ "Consistently enriched",
      N_Depleted == N_Sites ~ "Consistently depleted",
      N_Enriched >= N_Sites - 1 ~ "Mostly enriched",
      N_Depleted >= N_Sites - 1 ~ "Mostly depleted",
      TRUE ~ "Variable"
    )
  ) %>%
  dplyr::arrange(desc(N_Enriched), desc(Mean_Log2FC))

# 1. Top 10 ENRICHED functions (Fold_Change > 2)
cat("=== TOP 10 FORAM-ENRICHED FUNCTIONS ===\n")
top_enriched <- enrichment_foram %>%
  dplyr::filter(Enrichment_Category == "Foram-enriched (>2x)") %>%
  dplyr::arrange(desc(Fold_Change)) %>%
  head(10)
print(top_enriched %>% dplyr::select(Function, Foraminifera, Environment_Mean, Fold_Change, Log2_FC))

# 2. Top 10 DEPLETED functions (Fold_Change < 0.5)
cat("\n=== TOP 10 FORAM-DEPLETED FUNCTIONS ===\n")
top_depleted <- enrichment_foram %>%
  dplyr::filter(Enrichment_Category == "Foram-depleted (<0.5x)") %>%
  dplyr::arrange(Fold_Change) %>%
  head(10)
print(top_depleted %>% dplyr::select(Function, Foraminifera, Environment_Mean, Fold_Change, Log2_FC))

# 3. NMDS statistics
cat("\n=== NMDS STATISTICS ===\n")
cat("All samples - Stress:", round(func_nmds_all$stress, 3), "\n")
cat("All samples - ANOSIM R:", round(func_anosim_all$statistic, 3), "p =", func_anosim_all$signif, "\n")
cat("\nForaminifera only - Stress:", round(func_nmds_foram$stress, 3), "\n")
cat("\nPERMANOVA (Foraminifera):\n")
print(func_permanova_foram)

# 4. Consistency across sites
cat("\n=== CONSISTENTLY ENRICHED (ALL 4 SITES) ===\n")
consistently_enriched <- consistency_analysis %>%
  dplyr::filter(Consistency == "Consistently enriched") %>%
  dplyr::arrange(desc(Mean_Log2FC))
print(consistently_enriched)

cat("\n=== MOSTLY ENRICHED (3+ SITES) ===\n")
mostly_enriched <- consistency_analysis %>%
  dplyr::filter(Consistency == "Mostly enriched") %>%
  dplyr::arrange(desc(Mean_Log2FC))
print(mostly_enriched)

cat("\n=== CONSISTENTLY ENRICHED (ALL 4 SITES) ===\n")
print(consistency_analysis %>% dplyr::filter(Consistency == "Consistently enriched"))

##############################################
##  EXPORT SUPPLEMENTARY TABLES             ##
##  (Statistics and Enrichment Results)     ##
##############################################

cat("\n=== EXPORTING SUPPLEMENTARY TABLES TO INTERPRET FIGURE 5 ===\n")

# Note: Supplementary_Material_S7 (FAPROTAX input/output) already exists
# We are now exporting Tables S8-S13 (statistical results)

# ========================================
# TABLE S8: ASSIGNMENT RATE STATISTICS
# ========================================

cat("\n--- Preparing Table S8: Assignment rate statistics ---\n")

# Summary statistics by sample type
s8_summary <- assignment_summary %>%
  dplyr::mutate(
    Mean_Assigned_perc = round(Mean_Assigned_perc, 2),
    SD_Assigned_perc = round(SD_Assigned_perc, 2),
    Mean_Unassigned_perc = round(Mean_Unassigned_perc, 2),
    SD_Unassigned_perc = round(SD_Unassigned_perc, 2),
    Section = "Summary_by_sample_type"
  ) %>%
  dplyr::relocate(Section)

# Kruskal-Wallis test
s8_kruskal <- data.frame(
  Section = "Statistical_test",
  Test = "Kruskal-Wallis",
  Variable = "Assigned_percentage",
  Statistic = paste0("χ² = ", round(kruskal_test$statistic, 3)),
  df = kruskal_test$parameter,
  p_value = round(kruskal_test$p.value, 4),
  stringsAsFactors = FALSE
)

# Export as single table
write.table(s8_summary, 
            "../output/Supplementary_Tables/Table_S8_Assignment_Rate_Statistics.tsv",
            sep = "\t", row.names = FALSE, quote = FALSE)

# Append statistical test
write.table(s8_kruskal, 
            "../output/Supplementary_Tables/Table_S8_Assignment_Rate_Statistics.tsv",
            sep = "\t", row.names = FALSE, quote = FALSE, 
            append = TRUE, col.names = FALSE)

cat("✓ Table S8: Assignment rate statistics\n")

# ========================================
# TABLE S9: PERMANOVA RESULTS
# ========================================

cat("\n--- Preparing Table S9: PERMANOVA results ---\n")

# Function to extract PERMANOVA in clean format
extract_permanova_functional <- function(permanova_result, dataset_name) {
  perm_df <- as.data.frame(permanova_result)
  perm_df$Term <- rownames(perm_df)
  perm_df$Dataset <- dataset_name
  
  perm_df <- perm_df %>% 
    dplyr::select(Dataset, Term, Df, SumOfSqs, R2, F, `Pr(>F)`) %>%
    dplyr::rename(
      df = Df,
      SS = SumOfSqs,
      F_statistic = F,
      p_value = `Pr(>F)`
    ) %>%
    dplyr::mutate(
      SS = round(SS, 4),
      R2 = round(R2, 4),
      F_statistic = round(F_statistic, 3),
      p_value = round(p_value, 4)
    )
  
  return(perm_df)
}

# PERMANOVA for all samples (by Sample_type)
cat("Running PERMANOVA for all samples...\n")
func_permanova_all <- adonis2(
  func_mv_all$community ~ Sample_type,
  data = func_mv_all$metadata,
  permutations = 999,
  method = "bray"
)

permanova_all_clean <- extract_permanova_functional(func_permanova_all, "All_samples")
permanova_foram_clean <- extract_permanova_functional(func_permanova_foram, "Foraminifera_only")

s9_permanova <- rbind(permanova_all_clean, permanova_foram_clean)

write.table(s9_permanova, 
            "../output/Supplementary_Tables/Table_S9_PERMANOVA_Functional.tsv",
            sep = "\t", row.names = FALSE, quote = FALSE)

cat("✓ Table S9: PERMANOVA results for functional profiles\n")

# ========================================
# TABLE S10: ANOSIM AND BETADISPERSION
# ========================================

cat("\n--- Preparing Table S10: ANOSIM and Betadispersion tests ---\n")

# ANOSIM result
s10_anosim <- data.frame(
  Dataset = "All_samples",
  Test = "ANOSIM",
  Factor = "Sample_type",
  Statistic = round(func_anosim_all$statistic, 3),
  F_statistic = NA,
  df1 = NA,
  df2 = NA,
  p_value = func_anosim_all$signif,
  Permutations = 999,
  stringsAsFactors = FALSE
)

# Function to extract betadispersion
extract_betadisp_functional <- function(betadisp_test, factor_name, dataset_name) {
  data.frame(
    Dataset = dataset_name,
    Test = "Betadispersion",
    Factor = factor_name,
    Statistic = round(betadisp_test$tab$F[1], 3),
    F_statistic = round(betadisp_test$tab$F[1], 3),
    df1 = betadisp_test$tab$Df[1],
    df2 = betadisp_test$tab$Df[2],
    p_value = round(betadisp_test$tab$`Pr(>F)`[1], 4),
    Permutations = NA,
    stringsAsFactors = FALSE
  )
}

s10_betadisp <- rbind(
  extract_betadisp_functional(func_betadisp_test_all, "Sample_type", "All_samples"),
  extract_betadisp_functional(func_betadisp_test_site, "Site", "Foraminifera_only"),
  extract_betadisp_functional(func_betadisp_test_depth, "Depth", "Foraminifera_only"),
  extract_betadisp_functional(func_betadisp_test_substrate, "Substrate", "Foraminifera_only")
)

# Combine ANOSIM and betadispersion
s10_combined <- rbind(s10_anosim, s10_betadisp)

write.table(s10_combined, 
            "../output/Supplementary_Tables/Table_S10_ANOSIM_Betadispersion.tsv",
            sep = "\t", row.names = FALSE, quote = FALSE)

cat("✓ Table S10: ANOSIM and Betadispersion tests\n")

# ========================================
# TABLE S11: OVERALL ENRICHMENT
# ========================================

cat("\n--- Preparing Table S11: Overall enrichment analysis ---\n")

# Recalculate with 0.5-fold threshold
enrichment_foram_updated <- enrichment_foram %>%
  dplyr::mutate(
    Enrichment_Category = case_when(
      Fold_Change > 2 ~ "Foram-enriched (>2×)",
      Fold_Change < 0.5 ~ "Foram-depleted (<0.5×)",
      TRUE ~ "Similar (0.5-2×)"
    )
  )

s11_enrichment_overall <- enrichment_foram_updated %>%
  dplyr::select(Function, Foraminifera, Sediment, Seawater, 
                Environment_Mean, Fold_Change, Log2_FC, Enrichment_Category) %>%
  dplyr::arrange(desc(Fold_Change)) %>%
  dplyr::mutate(
    Foraminifera = round(Foraminifera, 6),
    Sediment = round(Sediment, 6),
    Seawater = round(Seawater, 6),
    Environment_Mean = round(Environment_Mean, 6),
    Fold_Change = round(Fold_Change, 3),
    Log2_FC = round(Log2_FC, 3)
  )

write.table(s11_enrichment_overall, 
            "../output/Supplementary_Tables/Table_S11_Enrichment_Overall.tsv",
            sep = "\t", row.names = FALSE, quote = FALSE)

cat("✓ Table S11: Overall enrichment (Foraminifera vs Environment)\n")

# ========================================
# TABLE S12: CONSISTENCY ACROSS SITES
# ========================================

cat("\n--- Preparing Table S12: Consistency across sites ---\n")

# Recalculate with updated threshold
consistency_analysis_updated <- enrichment_per_site %>%
  dplyr::mutate(
    Enrichment_Category = case_when(
      Fold_Change > 2 ~ "Foram-enriched (>2×)",
      Fold_Change < 0.5 ~ "Foram-depleted (<0.5×)",
      TRUE ~ "Similar (0.5-2×)"
    )
  ) %>%
  dplyr::group_by(Function) %>%
  summarise(
    N_Sites = n(),
    N_Enriched = sum(Enrichment_Category == "Foram-enriched (>2×)"),
    N_Depleted = sum(Enrichment_Category == "Foram-depleted (<0.5×)"),
    Mean_Log2FC = mean(Log2_FC, na.rm = TRUE),
    SD_Log2FC = sd(Log2_FC, na.rm = TRUE),
    Mean_Fold_Change = mean(Fold_Change, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  dplyr::mutate(
    Consistency = case_when(
      N_Enriched == N_Sites ~ "Consistently enriched (all sites)",
      N_Depleted == N_Sites ~ "Consistently depleted (all sites)",
      N_Enriched >= N_Sites - 1 ~ "Mostly enriched (≥3 sites)",
      N_Depleted >= N_Sites - 1 ~ "Mostly depleted (≥3 sites)",
      TRUE ~ "Variable"
    )
  ) %>%
  dplyr::arrange(desc(N_Enriched), desc(Mean_Log2FC))

s12_consistency <- consistency_analysis_updated %>%
  dplyr::mutate(
    Mean_Log2FC = round(Mean_Log2FC, 3),
    SD_Log2FC = round(SD_Log2FC, 3),
    Mean_Fold_Change = round(Mean_Fold_Change, 3)
  )

write.table(s12_consistency, 
            "../output/Supplementary_Tables/Table_S12_Enrichment_Consistency.tsv",
            sep = "\t", row.names = FALSE, quote = FALSE)

cat("✓ Table S12: Consistency across sites\n")

# ========================================
# TABLE S13: SITE-SPECIFIC ENRICHMENT
# ========================================

cat("\n--- Preparing Table S13: Site-specific enrichment ---\n")

enrichment_per_site_updated <- enrichment_per_site %>%
  dplyr::mutate(
    Enrichment_Category = case_when(
      Fold_Change > 2 ~ "Foram-enriched (>2×)",
      Fold_Change < 0.5 ~ "Foram-depleted (<0.5×)",
      TRUE ~ "Similar (0.5-2×)"
    )
  )

s13_site_specific <- enrichment_per_site_updated %>%
  dplyr::select(Site, Function, Foraminifera, Sediment, Seawater,
                Environment_Mean, Fold_Change, Log2_FC, Enrichment_Category) %>%
  dplyr::mutate(
    Foraminifera = round(Foraminifera, 6),
    Sediment = round(Sediment, 6),
    Seawater = round(Seawater, 6),
    Environment_Mean = round(Environment_Mean, 6),
    Fold_Change = round(Fold_Change, 3),
    Log2_FC = round(Log2_FC, 3)
  ) %>%
  dplyr::arrange(Site, desc(Fold_Change))

write.table(s13_site_specific, 
            "../output/Supplementary_Tables/Table_S13_Enrichment_Site_Specific.tsv",
            sep = "\t", row.names = FALSE, quote = FALSE)

cat("✓ Table S13: Site-specific enrichment details\n")

# ========================================
# SUMMARY OF RESULTS
# ========================================

cat("\n--- Summary of enrichment analysis ---\n")

# Summary of enrichment categories
enrichment_summary <- s11_enrichment_overall %>%
  dplyr::group_by(Enrichment_Category) %>%
  dplyr::summarise(
    n_functions = n(),
    .groups = "drop"
  )

cat("\nEnrichment summary:\n")
print(enrichment_summary)

# Consistently enriched functions (all 4 sites)
consistently_enriched <- s12_consistency %>%
  dplyr::filter(Consistency == "Consistently enriched (all sites)") %>%
  dplyr::select(Function, N_Enriched, Mean_Fold_Change, Mean_Log2FC, Consistency)

cat("\nConsistently enriched functions (all 4 sites):", nrow(consistently_enriched), "\n")
print(consistently_enriched)

# Consistently depleted functions (all 4 sites)
consistently_depleted <- s12_consistency %>%
  dplyr::filter(Consistency == "Consistently depleted (all sites)") %>%
  dplyr::select(Function, N_Depleted, Mean_Fold_Change, Mean_Log2FC, Consistency)

cat("\nConsistently depleted functions (all 4 sites):", nrow(consistently_depleted), "\n")
print(consistently_depleted)

# ========================================
# EXPORT SUMMARY
# ========================================

cat("\n")
cat(strrep("=", 60), "\n")
cat("SUPPLEMENTARY TABLES EXPORT COMPLETE\n")
cat(strrep("=", 60), "\n")
cat("\nFunctional profiling supplementary files:\n")
cat("  Supplementary_Material_S7 - FAPROTAX input/output files\n")
cat("  Table_S8  - Assignment rate statistics\n")
cat("  Table_S9  - PERMANOVA results\n")
cat("  Table_S10 - ANOSIM and Betadispersion tests\n")
cat("  Table_S11 - Overall enrichment analysis\n")
cat("  Table_S12 - Consistency across sites\n")
cat("  Table_S13 - Site-specific enrichment details\n")
cat("\n")
cat("All supplementary tables saved to: ../output/Supplementary_Tables/\n")
cat("\n")


